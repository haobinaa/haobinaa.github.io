<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="//cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.min.js" rel="stylesheet" type="text/css">







  

<link href="//cdn.staticfile.org/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="BlockingQueue 介绍BlockingQueue 是一个先进先出的队列（Queue）, 并且当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。 BlockingQueue 对插入、删除、获取元素在不同场景下提供了不同的操作:     抛异常 返回特殊值 阻塞等待 阻塞等待直至超时     插入 add(e) o">
<meta property="og:type" content="article">
<meta property="og:title" content="BlockingQueue">
<meta property="og:url" content="http://yoursite.com/2020/12/21/并发/BlockingQueue/index.html">
<meta property="og:site_name" content="Do Or Die">
<meta property="og:description" content="BlockingQueue 介绍BlockingQueue 是一个先进先出的队列（Queue）, 并且当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。 BlockingQueue 对插入、删除、获取元素在不同场景下提供了不同的操作:     抛异常 返回特殊值 阻塞等待 阻塞等待直至超时     插入 add(e) o">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-12-28T08:06:19.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BlockingQueue">
<meta name="twitter:description" content="BlockingQueue 介绍BlockingQueue 是一个先进先出的队列（Queue）, 并且当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。 BlockingQueue 对插入、删除、获取元素在不同场景下提供了不同的操作:     抛异常 返回特殊值 阻塞等待 阻塞等待直至超时     插入 add(e) o">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/12/21/并发/BlockingQueue/">





  <title>BlockingQueue | Do Or Die</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Do Or Die</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/并发/BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leo Hao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Do Or Die">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">BlockingQueue</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-21T19:13:32+08:00">
                2020-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="BlockingQueue-介绍"><a href="#BlockingQueue-介绍" class="headerlink" title="BlockingQueue 介绍"></a>BlockingQueue 介绍</h3><p>BlockingQueue 是一个先进先出的队列（Queue）, 并且当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p>
<p>BlockingQueue 对插入、删除、获取元素在不同场景下提供了不同的操作:</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>返回特殊值</th>
<th>阻塞等待</th>
<th>阻塞等待直至超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>删除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>获取</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>我们重点关注 <code>put</code> 和 <code>take</code> 这两个阻塞操作， BlockingQueue 主要是于消费者-生产者场景的一个线程安全容器</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><ul>
<li>ArrayBlockingQueue 是 BlockingQueue 的一个有界队列实现，底层采取数组</li>
<li>并发控制采取可重入锁， 插入和读取操作都需要获取锁</li>
<li>如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程</li>
<li>如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程</li>
</ul>
<h4 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 用于存放元素的数组</span><br><span class="line">final Object[] items;</span><br><span class="line">// 下一次读取操作的位置</span><br><span class="line">int takeIndex;</span><br><span class="line">// 下一次写入操作的位置</span><br><span class="line">int putIndex;</span><br><span class="line">// 队列中的元素数量</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">// 以下几个就是控制并发用的同步器</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line">// 队列为空的条件队列</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">// 队列满的条件队列</span><br><span class="line">private final Condition notFull;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞操作-take-amp-put"><a href="#阻塞操作-take-amp-put" class="headerlink" title="阻塞操作 take &amp; put"></a>阻塞操作 take &amp; put</h4><p>put 操作流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 插入前先获取锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果队列满了， 写操作线程进入条件队列等待</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        // 元素入队</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 入队操作</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    // 入队</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 循环使用 index</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    // 队列已经有数据了，唤醒等待队消费者</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>take 操作流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果队列为空， 读操作线程挂起等待</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        // 出队操作</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    // 唤醒队列满时等待的写线程</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><ul>
<li>LinkedBlockingQueue 底层基于单向链表，可以作为无界队列也可作为有界队列</li>
<li>如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）</li>
<li>如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）</li>
</ul>
<h4 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h4><p>构造方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 无界队列构造方法</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 有界队列构造方法</span><br><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 队列容量</span><br><span class="line">private final int capacity;</span><br><span class="line"></span><br><span class="line">// 队列中的元素数量</span><br><span class="line">private final AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">// 队头</span><br><span class="line">private transient Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">// 队尾</span><br><span class="line">private transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">// take, poll, peek 等读操作的方法需要获取到这个锁</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">// put, offer 等写操作的方法需要获取到这个锁</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure></p>
<h4 id="阻塞操作-put-amp-take"><a href="#阻塞操作-put-amp-take" class="headerlink" title="阻塞操作 put &amp; take"></a>阻塞操作 put &amp; take</h4><p>put 操作流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // 标识成功、失败的标志</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    // 必须要获取到 putLock 才可以进行插入操作</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果队列满，等待 notFull 的条件满足。</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        // 入队</span><br><span class="line">        enqueue(node);</span><br><span class="line">        // count 原子加 1，c 还是加 1 前的值</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        // 如果这个元素入队后，还有至少一个槽可以使用，调用 notFull.signal() 唤醒等待线程。</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 入队后，释放掉 putLock</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 c == 0，那么代表队列在这个元素入队前是空的（不包括head空节点），</span><br><span class="line">    // 那么所有的读线程都在等待 notEmpty 这个条件，等待唤醒，这里做一次唤醒操作</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入队的代码非常简单，就是将 last 属性指向这个新元素，并且让原队尾的 next 指向这个元素</span><br><span class="line">// 这里入队没有并发问题，因为只有获取到 putLock 独占锁以后，才可以进行此操作</span><br><span class="line">private void enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line">    // assert putLock.isHeldByCurrentThread();</span><br><span class="line">    // assert last.next == null;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素入队后，如果需要，调用这个方法唤醒读线程来读</span><br><span class="line">private void signalNotEmpty() &#123;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>take 操作流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    // 首先，需要获取到 takeLock 才能进行出队操作</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果队列为空，等待 notEmpty 这个条件满足再继续执行</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        // 出队</span><br><span class="line">        x = dequeue();</span><br><span class="line">        // count 进行原子减 1</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        // 如果这次出队后，队列中至少还有一个元素，那么调用 notEmpty.signal() 唤醒其他的读线程</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 出队后释放掉 takeLock</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 c == capacity，那么说明在这个 take 方法发生的时候，队列是满的</span><br><span class="line">    // 既然出队了一个，那么意味着队列不满了，唤醒写线程去写</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">// 取队头，出队</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert takeLock.isHeldByCurrentThread();</span><br><span class="line">    // assert head.item == null;</span><br><span class="line">    // 之前说了，头结点是空的</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; // help GC</span><br><span class="line">    // 设置这个为新的头结点</span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = null;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">// 元素出队后，如果需要，调用这个方法唤醒写线程来写</span><br><span class="line">private void signalNotFull() &#123;</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><ul>
<li>同步队列: 当一个线程往队列中写入一个元素时，写入操作不会立即返回，需要等待另一个线程来将这个元素拿走；同理，当一个读线程做读操作的时候，同样需要一个相匹配的写线程的写操作</li>
<li>SynchronousQueue 不提供任何空间来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费</li>
<li>没有 peek 方法(直接返回null)</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 构造时，我们可以指定公平模式还是非公平模式，区别之后再说</span><br><span class="line">public SynchronousQueue(boolean fair) &#123;</span><br><span class="line">    transferer = fair ? new TransferQueue() : new TransferStack();</span><br><span class="line">&#125;</span><br><span class="line">abstract static class Transferer &#123;</span><br><span class="line">    // 从方法名上大概就知道，这个方法用于转移元素，从生产者手上转到消费者手上</span><br><span class="line">    // 也可以被动地，消费者调用这个方法来从生产者手上取元素</span><br><span class="line">    // 第一个参数 e 如果不是 null，代表场景为：将元素从生产者转移给消费者</span><br><span class="line">    // 如果是 null，代表消费者等待生产者提供元素，然后返回值就是相应的生产者提供的元素</span><br><span class="line">    // 第二个参数代表是否设置超时，如果设置超时，超时时间是第三个参数的值</span><br><span class="line">    // 返回值如果是 null，代表超时，或者中断。具体是哪个，可以通过检测中断状态得到。</span><br><span class="line">    abstract Object transfer(Object e, boolean timed, long nanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="put-amp-take-公平模式"><a href="#put-amp-take-公平模式" class="headerlink" title="put &amp; take(公平模式)"></a>put &amp; take(公平模式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 写入值</span><br><span class="line">public void put(E o) throws InterruptedException &#123;</span><br><span class="line">    if (o == null) throw new NullPointerException();</span><br><span class="line">    if (transferer.transfer(o, false, 0) == null) &#123; // 1</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 读取值并移除</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    Object e = transferer.transfer(null, false, 0); // 2</span><br><span class="line">    if (e != null)</span><br><span class="line">        return (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    throw new InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="transfer-分析"><a href="#transfer-分析" class="headerlink" title="transfer 分析"></a>transfer 分析</h4><p><code>put(E o)</code> 和 <code>take()</code> 都调用了 <code>transferer.transfer(....)</code>， 区别是 take 操作的第一个参数为 null。<br><code>transfer</code> 整体的设计思路如下:</p>
<ol>
<li>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而队列中的元素也都是写线程）。这种情况下，将当前线程加入到等待队列</li>
<li>如果队列中有等待节点，而且与当前操作可以匹配（如队列中都是读操作线程，当前线程是写操作线程，反之亦然）。这种情况下，匹配等待队列的队头，出队，返回相应数据</li>
</ol>
<p>等待队列 QNode 的结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class QNode &#123;</span><br><span class="line">    volatile QNode next;          // 可以看出来，等待队列是单向链表</span><br><span class="line">    volatile Object item;        </span><br><span class="line">    volatile Thread waiter;       // 将线程对象保存在这里，用于挂起和唤醒</span><br><span class="line">    final boolean isData;         // 用于判断是写线程节点(isData == true)，还是读线程节点</span><br><span class="line"></span><br><span class="line">    QNode(Object item, boolean isData) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">        this.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>整个transfer流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">Object transfer(Object e, boolean timed, long nanos) &#123;</span><br><span class="line"></span><br><span class="line">    QNode s = null;</span><br><span class="line">    boolean isData = (e != null);</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        QNode t = tail;</span><br><span class="line">        QNode h = head;</span><br><span class="line">        if (t == null || h == null)</span><br><span class="line">            continue;                       </span><br><span class="line"></span><br><span class="line">        // 队列空，或队列中节点类型和当前节点一致， 直接入队</span><br><span class="line">        if (h == t || t.isData == isData) &#123;</span><br><span class="line">            QNode tn = t.next;</span><br><span class="line">            // t != tail 说明刚刚有节点入队，continue</span><br><span class="line">            if (t != tail)                  // inconsistent read</span><br><span class="line">                continue;</span><br><span class="line">            // 有其他节点入队，但是 tail 还是指向原来的，此时设置 tail 即可</span><br><span class="line">            if (tn != null) &#123;               // lagging tail</span><br><span class="line">                // 这个方法就是：如果 tail 此时为 t 的话，设置为 tn</span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // </span><br><span class="line">            if (timed &amp;&amp; nanos &lt;= 0)        // can&apos;t wait</span><br><span class="line">                return null;</span><br><span class="line">            if (s == null)</span><br><span class="line">                s = new QNode(e, isData);</span><br><span class="line">            // 将当前节点，插入到 tail 的后面</span><br><span class="line">            if (!t.casNext(null, s))        // failed to link in</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            // 将当前节点设置为新的 tail</span><br><span class="line">            advanceTail(t, s);              // swing tail and wait</span><br><span class="line">            // 自旋或阻塞，直到满足条件</span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            // 到这里，说明之前入队的线程被唤醒了，准备往下执行</span><br><span class="line">            if (x == s) &#123;                   // wait was cancelled</span><br><span class="line">                clean(t, s);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!s.isOffList()) &#123;           // not already unlinked</span><br><span class="line">                advanceHead(t, s);          // unlink if head</span><br><span class="line">                if (x != null)              // and forget fields</span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = null;</span><br><span class="line">            &#125;</span><br><span class="line">            return (x != null) ? x : e;</span><br><span class="line"></span><br><span class="line">        // 有相应的读或写相匹配的情况</span><br><span class="line">        &#125; else &#123;                           </span><br><span class="line">            QNode m = h.next;               // node to fulfill</span><br><span class="line">            if (t != tail || m == null || h != head)</span><br><span class="line">                continue;                  </span><br><span class="line"></span><br><span class="line">            Object x = m.item;</span><br><span class="line">            if (isData == (x != null) ||    // m already fulfilled</span><br><span class="line">                x == m ||                   // m cancelled</span><br><span class="line">                !m.casItem(x, e)) &#123;         // lost CAS</span><br><span class="line">                advanceHead(h, m);          // dequeue and retry</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            advanceHead(h, m);              // successfully fulfilled</span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            return (x != null) ? x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void advanceTail(QNode t, QNode nt) &#123;</span><br><span class="line">    if (tail == t)</span><br><span class="line">        UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 自旋或阻塞，直到满足条件，这个方法返回</span><br><span class="line">Object awaitFulfill(QNode s, Object e, boolean timed, long nanos) &#123;</span><br><span class="line"></span><br><span class="line">    long lastTime = timed ? System.nanoTime() : 0;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    // 判断需要自旋的次数，</span><br><span class="line">    int spins = ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 如果被中断了，那么取消这个节点</span><br><span class="line">        if (w.isInterrupted())</span><br><span class="line">            // 就是将当前节点 s 中的 item 属性设置为 this</span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        Object x = s.item;</span><br><span class="line">        // 这里是这个方法的唯一的出口</span><br><span class="line">        if (x != e)</span><br><span class="line">            return x;</span><br><span class="line">        // 如果需要，检测是否超时</span><br><span class="line">        if (timed) &#123;</span><br><span class="line">            long now = System.nanoTime();</span><br><span class="line">            nanos -= now - lastTime;</span><br><span class="line">            lastTime = now;</span><br><span class="line">            if (nanos &lt;= 0) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (spins &gt; 0)</span><br><span class="line">            --spins;</span><br><span class="line">        // 如果自旋达到了最大的次数，那么检测</span><br><span class="line">        else if (s.waiter == null)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        // 如果自旋到了最大的次数，那么线程挂起，等待唤醒</span><br><span class="line">        else if (!timed)</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">        // spinForTimeoutThreshold 这个之前讲 AQS 的时候其实也说过，剩余时间小于这个阈值的时候，就</span><br><span class="line">        // 不要进行挂起了，自旋的性能会比较好</span><br><span class="line">        else if (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="非公平模式-TransferStack"><a href="#非公平模式-TransferStack" class="headerlink" title="非公平模式 TransferStack"></a>非公平模式 TransferStack</h4><p>上面分析了公平模式 TransferQueue, TransferStack 流程类似:</p>
<ol>
<li>如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而栈中的元素也都是写线程）。这种情况下，将当前线程加入到等待栈中，等待配对</li>
<li>如果栈中有等待节点，而且与当前操作可以匹配（如栈里面都是读操作线程，当前线程是写操作线程，反之亦然）。将当前节点压入栈顶，和栈中的节点进行匹配，然后将这两个节点出栈</li>
<li>如果栈顶是进行匹配而入栈的节点，帮助其进行匹配并出栈，然后再继续操作</li>
</ol>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><ul>
<li>PriorityQueue 的线程安全版本</li>
<li>插入值不可为null， 并且是 comparable 的（否则会抛出 ClassCastException)</li>
<li>相较于其他 BlockingQueue，PriorityBlockingQueue 的 put 操作不会阻塞, 因为它是无界队列</li>
</ul>
<h4 id="主要属性-2"><a href="#主要属性-2" class="headerlink" title="主要属性"></a>主要属性</h4><p>前面说了 PriorityBlockingQueue 是 PriorityQueue 的线程安全版本， 所以基本的存储结构也与 PriorityQueue 一样.</p>
<ul>
<li>使用一个基于数组的二叉堆来存储， 采取同一个 lock 来控制并发</li>
<li>二叉堆(小顶堆), 每个节点的值都小于其左右子节点的值, 二叉堆中最小的值就是根节点</li>
<li>对于数组中的元素 <code>a[i]</code>，其左子节点为 <code>a[2*i+1]</code>，其右子节点为 <code>a[2*i + 2]</code>，其父节点为 <code>a[(i-1)/2]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法中，如果不指定大小的话，默认大小为 11</span><br><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">// 数组的最大容量</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">// 这个就是存放数据的数组</span><br><span class="line">private transient Object[] queue;</span><br><span class="line"></span><br><span class="line">// 队列当前大小</span><br><span class="line">private transient int size;</span><br><span class="line"></span><br><span class="line">// 大小比较器，如果按照自然序排序，那么此属性可设置为 null</span><br><span class="line">private transient Comparator&lt;? super E&gt; comparator;</span><br><span class="line"></span><br><span class="line">// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">// 由上面的 lock 属性创建</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作</span><br><span class="line">// 其使用 CAS 操作</span><br><span class="line">private transient volatile int allocationSpinLock;</span><br><span class="line"></span><br><span class="line">// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化</span><br><span class="line">private PriorityQueue q;</span><br></pre></td></tr></table></figure>
<h4 id="自动扩容"><a href="#自动扩容" class="headerlink" title="自动扩容"></a>自动扩容</h4><p>PriorityBlockingQueue 实现了并发安全的自动扩容， <code>tryGrow</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private void tryGrow(Object[] array, int oldCap) &#123;</span><br><span class="line">    // 先释放锁， 后面重新获取锁</span><br><span class="line">    // 这里先释放独占锁， 这样读操作和扩容操作就可以同时进行了</span><br><span class="line">    lock.unlock(); </span><br><span class="line">    Object[] newArray = null;</span><br><span class="line">    // 用 CAS 操作将 allocationSpinLock 由 0 变为 1，也算是获取锁</span><br><span class="line">    if (allocationSpinLock == 0 &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,</span><br><span class="line">                                 0, 1)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果节点个数小于 64，那么增加的 oldCap + 2 的容量</span><br><span class="line">            // 如果节点数大于等于 64，那么增加 oldCap 的一半</span><br><span class="line">            // 所以节点数较小时，增长得快一些</span><br><span class="line">            int newCap = oldCap + ((oldCap &lt; 64) ?</span><br><span class="line">                                   (oldCap + 2) :</span><br><span class="line">                                   (oldCap &gt;&gt; 1));</span><br><span class="line">            // 这里有可能溢出</span><br><span class="line">            if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow</span><br><span class="line">                int minCap = oldCap + 1;</span><br><span class="line">                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    throw new OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果 queue != array，那么说明有其他线程给 queue 分配了其他的空间</span><br><span class="line">            if (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                // 分配一个新的大数组</span><br><span class="line">                newArray = new Object[newCap];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 重置，也就是释放锁</span><br><span class="line">            allocationSpinLock = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果有其他的线程也在做扩容的操作</span><br><span class="line">    if (newArray == null) </span><br><span class="line">        Thread.yield();</span><br><span class="line">    // 重新获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    // 将原来数组中的元素复制到新分配的大数组中</span><br><span class="line">    if (newArray != null &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, 0, newArray, 0, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="put-amp-take-操作"><a href="#put-amp-take-操作" class="headerlink" title="put &amp; take 操作"></a>put &amp; take 操作</h4><p>put 流程与 PriorityQueue 类似， 都是先插入到最后，然后与父节点比较，直到父节点小于插入元素，不过加了一个 lock，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) &#123;</span><br><span class="line">    // 直接调用 offer 方法，因为前面我们也说了，在这里，put 方法不会阻塞</span><br><span class="line">    offer(e); </span><br><span class="line">&#125;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 首先获取到独占锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    int n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    // 如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了</span><br><span class="line">    while ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    try &#123;</span><br><span class="line">        Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">        // 节点添加到二叉堆中</span><br><span class="line">        if (cmp == null)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        else</span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        // 更新 size</span><br><span class="line">        size = n + 1;</span><br><span class="line">        // 唤醒等待的读线程</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>take 流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 独占锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    try &#123;</span><br><span class="line">        // dequeue 出队, 如果没有元素就阻塞在这里</span><br><span class="line">        while ( (result = dequeue()) == null)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    int n = size - 1;</span><br><span class="line">    if (n &lt; 0)</span><br><span class="line">        return null;</span><br><span class="line">    else &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        // 队头，用于返回</span><br><span class="line">        E result = (E) array[0];</span><br><span class="line">        // 队尾元素先取出</span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        // 队尾置空</span><br><span class="line">        array[n] = null;</span><br><span class="line">        Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">        if (cmp == null)</span><br><span class="line">            siftDownComparable(0, x, array, n);</span><br><span class="line">        else</span><br><span class="line">            siftDownUsingComparator(0, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 出队后调整树的结构， 使其符合小顶堆</span><br><span class="line">private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,</span><br><span class="line">                                           int n) &#123;</span><br><span class="line">    if (n &gt; 0) &#123;</span><br><span class="line">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;</span><br><span class="line">        // 这里得到的 half 肯定是非叶节点</span><br><span class="line">        // a[n] 是最后一个元素，其父节点是 a[(n-1)/2]。所以 n &gt;&gt;&gt; 1 代表的节点肯定不是叶子节点</span><br><span class="line">        int half = n &gt;&gt;&gt; 1; // 得到 half = 4</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            // 先取左子节点</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1; // 得到 child = 1</span><br><span class="line">            Object c = array[child];  // c = 12</span><br><span class="line">            int right = child + 1;  // right = 2</span><br><span class="line">            // 如果右子节点存在，而且比左子节点小</span><br><span class="line">            // 此时 array[right] = 20，所以条件不满足</span><br><span class="line">            if (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            // key = 17, c = 12，所以条件不满足</span><br><span class="line">            if (key.compareTo((T) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 把 12 填充到根节点</span><br><span class="line">            array[k] = c;</span><br><span class="line">            // k 赋值后为 1</span><br><span class="line">            k = child;</span><br><span class="line">            // 一轮过后，我们发现，12 左边的子树和刚刚的差不多，都是缺少根节点，接下来处理就简单了</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/14/并发/异步编程CompletableFuture使用/" rel="next" title="异步编程CompletableFuture使用">
                <i class="fa fa-chevron-left"></i> 异步编程CompletableFuture使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/07/池化设计之CommonPool/" rel="prev" title="池化设计之CommonPool">
                池化设计之CommonPool <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">Leo Hao</p>
            <p class="site-description motion-element" itemprop="description">勿在浮沙筑高台</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue-介绍"><span class="nav-number">1.</span> <span class="nav-text">BlockingQueue 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">2.</span> <span class="nav-text">ArrayBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要属性"><span class="nav-number">2.1.</span> <span class="nav-text">主要属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞操作-take-amp-put"><span class="nav-number">2.2.</span> <span class="nav-text">阻塞操作 take &amp; put</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">3.</span> <span class="nav-text">LinkedBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要属性-1"><span class="nav-number">3.1.</span> <span class="nav-text">主要属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞操作-put-amp-take"><span class="nav-number">3.2.</span> <span class="nav-text">阻塞操作 put &amp; take</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">4.</span> <span class="nav-text">SynchronousQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-amp-take-公平模式"><span class="nav-number">4.2.</span> <span class="nav-text">put &amp; take(公平模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer-分析"><span class="nav-number">4.3.</span> <span class="nav-text">transfer 分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非公平模式-TransferStack"><span class="nav-number">4.4.</span> <span class="nav-text">非公平模式 TransferStack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">5.</span> <span class="nav-text">PriorityBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要属性-2"><span class="nav-number">5.1.</span> <span class="nav-text">主要属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动扩容"><span class="nav-number">5.2.</span> <span class="nav-text">自动扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-amp-take-操作"><span class="nav-number">5.3.</span> <span class="nav-text">put &amp; take 操作</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo Hao</span>

  
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdn.staticfile.org/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.staticfile.org/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.staticfile.org/velocity/1.2.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.staticfile.org/velocity/1.2.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.staticfile.org/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
