<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="概述使用线程时， 我们一般使用new Thread的方式, 如下:1234567new Thread(new Runnable() &amp;#123;	@Override	public void run() &amp;#123;		// TODO Auto-generated method stub	&amp;#125;&amp;#125;).start(); 这种方式有一些弊端：  每次new Thread新建对象性能差。">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池使用详解">
<meta property="og:url" content="http://yoursite.com/2018/09/15/并发/线程池使用总结/index.html">
<meta property="og:site_name" content="Do Or Die">
<meta property="og:description" content="概述使用线程时， 我们一般使用new Thread的方式, 如下:1234567new Thread(new Runnable() &amp;#123;	@Override	public void run() &amp;#123;		// TODO Auto-generated method stub	&amp;#125;&amp;#125;).start(); 这种方式有一些弊端：  每次new Thread新建对象性能差。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/Executor.png">
<meta property="og:image" content="http://yoursite.com/images/threadpool_process.png">
<meta property="og:image" content="http://yoursite.com/images/threadpool_handle_process.png">
<meta property="og:image" content="http://yoursite.com/images/workerProcess.png">
<meta property="og:updated_time" content="2019-02-11T10:01:30.610Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程池使用详解">
<meta name="twitter:description" content="概述使用线程时， 我们一般使用new Thread的方式, 如下:1234567new Thread(new Runnable() &amp;#123;	@Override	public void run() &amp;#123;		// TODO Auto-generated method stub	&amp;#125;&amp;#125;).start(); 这种方式有一些弊端：  每次new Thread新建对象性能差。">
<meta name="twitter:image" content="http://yoursite.com/images/Executor.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/15/并发/线程池使用总结/"/>





  <title>线程池使用详解 | Do Or Die</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Do Or Die</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/15/并发/线程池使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leo Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Do Or Die">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程池使用详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-15T14:12:02+08:00">
                2018-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用线程时， 我们一般使用new Thread的方式, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>这种方式有一些弊端：</p>
<ul>
<li>每次new Thread新建对象性能差。</li>
<li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom</li>
<li>缺乏更多功能，如定时执行、定期执行、线程中断</li>
</ul>
<p>java提供了四种线程池，相较之下有如下好处：</p>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<h3 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h3><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式的缺陷就是：在执行完任务之后无法获取执行结果。</p>
<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>Callable也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Callable一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future也是一个接口，定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法说明：</p>
<ul>
<li><p>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论<code>mayInterruptIfRunning</code>为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若<code>mayInterruptIfRunning</code>设置为true，则返回true，若<code>mayInterruptIfRunning</code>设置为false，则返回false；如果任务还没有执行，则无论<code>mayInterruptIfRunning</code>为true还是false，肯定返回true</p>
</li>
<li><p>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true</p>
</li>
<li><p>isDone方法表示任务是否已经完成，若任务完成，则返回true</p>
</li>
<li><p>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</p>
</li>
<li><p>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</p>
</li>
</ul>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br><span class="line"></span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>
<p>FutureTask提供了2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程池实现架构"><a href="#线程池实现架构" class="headerlink" title="线程池实现架构"></a>线程池实现架构</h3><p><img src="/images/Executor.png" alt=""></p>
<p>ThreadPoolExecutor实现了一般的线程池，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor的实现，然后增加了调度功能。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor，任务的执行者，线程池框架中几乎所有类都直接或者间接实现Executor接口，它是线程池框架的基础。Executor提供了一种将“任务提交”与“任务执行”分离开来的机制，它仅提供了一个Execute()方法用来执行已经提交的Runnable任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>ExecutorService提供了将任务提交给执行者的接口(submit方法)，让执行者执行任务(invokeAll, invokeAny方法)的接口等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 启动一次顺序关闭，执行以前提交的任务，但不接受新任务</span><br><span class="line">     */</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表</span><br><span class="line">     */</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果此执行程序已关闭，则返回 true。</span><br><span class="line">     */</span><br><span class="line">    boolean isShutdown();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果关闭后所有任务都已完成，则返回 true</span><br><span class="line">     */</span><br><span class="line">    boolean isTerminated();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行</span><br><span class="line">     */</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future</span><br><span class="line">     */</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                    long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h4><p>为ExecutorService的默认实现，AbstractExecutorService除了实现ExecutorService接口外，还提供了newTaskFor()方法返回一个RunnableFuture，在运行的时候，它将调用底层可调用任务，作为 Future 任务，它将生成可调用的结果作为其结果，并为底层任务提供取消操作</p>
<h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><p>继承ExecutorService，为一个“延迟”和“定期执行”的ExecutorService。他提供了一些如下几个方法安排任务在给定的延时执行或者周期性执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建并执行在给定延迟后启用的 ScheduledFuture。</span><br><span class="line">&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</span><br><span class="line"></span><br><span class="line">// 创建并执行在给定延迟后启用的一次性操作。</span><br><span class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</span><br><span class="line"></span><br><span class="line">// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；</span><br><span class="line">//也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。</span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</span><br><span class="line"></span><br><span class="line">// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。</span><br><span class="line">ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>ThreadPoolExecutor</code>继承于抽象类<code>AbstractExecutorService</code>， 是线程池的主要实现类</p>
<h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p><img src="/images/threadpool_process.png" alt=""></p>
<h4 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h4><p><img src="/images/threadpool_handle_process.png" alt=""></p>
<p>excute流程：</p>
<ol>
<li><p>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
</li>
<li><p>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
</li>
<li><p>如果无法将任务加入BlockingQueue（队列已满），则在非corePool中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 </p>
</li>
<li><p>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用<br>RejectedExecutionHandler.rejectedExecution()方法。 </p>
</li>
</ol>
<h5 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h5><ul>
<li><p>AbortPolicy: 为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出</p>
</li>
<li><p>DiscardPolicy: 直接抛弃，任务不执行，空方法</p>
</li>
<li><p>DiscardOldestPolicy： 从队列里面抛弃head的一个任务，并再次execute 此task</p>
</li>
<li><p>CallerRunsPolicy： 在调用execute的线程里面执行此command，会阻塞入口</p>
</li>
<li><p>用户自定义拒绝策略（最常用）：实现RejectedExecutionHandler，并自己定义策略模式 </p>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ctl变量"><a href="#ctl变量" class="headerlink" title="ctl变量"></a>ctl变量</h4><p>ThreadPoolExcuter是将两个内部值打包成一个值，即将workerCount和runState（运行状态）这两个值打包在一个ctl中，因为runState有5个值，需要3位，所以有3位表示runState，而其他29位表示为workerCount。而运行时要获取其他数据时，只需要对ctl进行拆包即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 与0做 |运算， 求出前三位状态位</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"> private static final int COUNT_BITS = Integer.SIZE - 3; </span><br><span class="line"> private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;  // 2^29-1</span><br><span class="line"></span><br><span class="line"> // runState is stored in the high-order bits</span><br><span class="line"> private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;  // 111</span><br><span class="line"> private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS; // 000</span><br><span class="line"> private static final int STOP       =  1 &lt;&lt; COUNT_BITS; // 001</span><br><span class="line"> private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS; // 010</span><br><span class="line"> private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS; // 100</span><br><span class="line"></span><br><span class="line"> // Packing and unpacking ctl  　　//拆包ctl，分别获取runState和WorkerCount</span><br><span class="line"> private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; // 取前三位状态位， ~CAPATITY为29个1</span><br><span class="line"> private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;　　// 取线程数</span><br><span class="line"> private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; // 拼出状态和线程数</span><br></pre></td></tr></table></figure></p>
<h4 id="关键的类成员"><a href="#关键的类成员" class="headerlink" title="关键的类成员"></a>关键的类成员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;  // 任务队列，我们的任务会添加到该队列里面，线程将从该队列获取任务来执行</span><br><span class="line"></span><br><span class="line"> private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//任务的执行值集合，来消费workQueue里面的任务</span><br><span class="line"></span><br><span class="line"> private volatile ThreadFactory threadFactory;//线程工厂</span><br><span class="line"></span><br><span class="line"> private volatile RejectedExecutionHandler handler;//拒绝策略，默认会抛出异异常，还要其他几种拒绝策略如下：</span><br><span class="line"></span><br><span class="line"> 1、CallerRunsPolicy：在调用者线程里面运行该任务</span><br><span class="line"> 2、DiscardPolicy：丢弃任务</span><br><span class="line"> 3、DiscardOldestPolicy：丢弃workQueue的头部任务</span><br><span class="line"></span><br><span class="line">private volatile int corePoolSize;//最下保活work数量</span><br><span class="line"></span><br><span class="line">private volatile int maximumPoolSize;//work上限</span><br></pre></td></tr></table></figure>
<h4 id="execute流程"><a href="#execute流程" class="headerlink" title="execute流程"></a>execute流程</h4><p>execute源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        //表示 “线程池状态” 和 “线程数” 的整数</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        // 如果当前线程数少于核心线程数，直接添加一个 worker 执行任务，</span><br><span class="line">        // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 添加任务成功，即结束</span><br><span class="line">        // 执行的结果，会包装到 FutureTask </span><br><span class="line">        // 返回 false 代表线程池不允许提交任务</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 到这说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败</span><br><span class="line">  </span><br><span class="line">        // 如果线程池处于 RUNNING ，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            /* 若任务进入 workQueue，我们是否需要开启新的线程</span><br><span class="line">             * 线程数在 [0, corePoolSize) 是无条件开启新线程的</span><br><span class="line">             * 若线程数已经大于等于 corePoolSize，则将任务添加到队列中，然后进到这里</span><br><span class="line">             */</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            // 若线程池不处于 RUNNING ，则移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            // 若线程池还是 RUNNING ，且线程数为 0，则开启新的线程</span><br><span class="line">            // 这块代码的真正意图：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        // 若 workQueue 满，到该分支</span><br><span class="line">        // 以 maximumPoolSize 为界创建新 worker，</span><br><span class="line">        // 若失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="addWorker流程"><a href="#addWorker流程" class="headerlink" title="addWorker流程"></a>addWorker流程</h4><p>addWorker源码流程:</p>
<ol>
<li>检查是否可以根据当前池状态和给定的边界（核心或最大)</li>
<li>添加新工作线程。如果是这样,工作线程数量会相应调整，如果可能的话,一个新的工作线程创建并启动</li>
<li>将firstTask作为其运行的第一项任务。</li>
<li>如果池已停止此方法返回false</li>
<li>如果线程工厂在被访问时未能创建线程,也返回false</li>
<li>如果线程创建失败，或者是由于线程工厂返回null，或者由于异常（通常是在调用Thread.start（）后的OOM）），我们干净地回滚</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">       // java标签</span><br><span class="line">       retry:</span><br><span class="line">       // 死循环</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           // 获取当前线程状态</span><br><span class="line">           int rs = runStateOf(c);</span><br><span class="line">           // Check if queue empty only if necessary.</span><br><span class="line">           // 这个逻辑判断有点绕可以改成 </span><br><span class="line">           // rs &gt;= shutdown &amp;&amp; (rs != shutdown || firstTask != null || workQueue.isEmpty())</span><br><span class="line">           // 逻辑判断成立可以分为以下几种情况均不接受新任务</span><br><span class="line">           // 1、rs &gt; shutdown:--不接受新任务</span><br><span class="line">           // 2、rs &gt;= shutdown &amp;&amp; firstTask != null:--不接受新任务</span><br><span class="line">           // 3、rs &gt;= shutdown &amp;&amp; workQueue.isEmppty:--不接受新任务</span><br><span class="line">           // 逻辑判断不成立</span><br><span class="line">           // 1、rs==shutdown&amp;&amp;firstTask != null:此时不接受新任务，但是仍会执行队列中的任务</span><br><span class="line">           // 2、rs==shotdown&amp;&amp;firstTask == null:会执行addWork(null,false)</span><br><span class="line">           //  防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span><br><span class="line">           //  添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp;! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp;! workQueue.isEmpty()))</span><br><span class="line">               return false;</span><br><span class="line">           // 死循环</span><br><span class="line">           // 如果线程池状态为RUNNING并且队列中还有需要执行的任务</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               // 获取线程池中线程数量</span><br><span class="line">               int wc = workerCountOf(c);</span><br><span class="line">               // 如果超出容量或者最大线程池容量不在接受新任务</span><br><span class="line">               if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   return false;</span><br><span class="line">               // 线程安全增加工作线程数</span><br><span class="line">               if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                   // 跳出retry</span><br><span class="line">                   break retry;</span><br><span class="line">               c = ctl.get();  // Re-read ctl</span><br><span class="line">               // 如果线程池状态发生变化，重新循环</span><br><span class="line">               if (runStateOf(c) != rs)</span><br><span class="line">                   continue retry;</span><br><span class="line">               // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 走到这里说明工作线程数增加成功</span><br><span class="line">       boolean workerStarted = false;</span><br><span class="line">       boolean workerAdded = false;</span><br><span class="line">       Worker w = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">           w = new Worker(firstTask);</span><br><span class="line">           final Thread t = w.thread;</span><br><span class="line">           if (t != null) &#123;</span><br><span class="line">               // 加锁</span><br><span class="line">               mainLock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                   int c = ctl.get();</span><br><span class="line">                   int rs = runStateOf(c);</span><br><span class="line">                   // RUNNING状态 || SHUTDONW状态下清理队列中剩余的任务</span><br><span class="line">                   if (rs &lt; SHUTDOWN ||</span><br><span class="line">                       (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                       // 检查线程状态</span><br><span class="line">                       if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                           throw new IllegalThreadStateException();</span><br><span class="line">                       // 将新启动的线程添加到线程池中</span><br><span class="line">                       workers.add(w);</span><br><span class="line">                       // 更新线程池线程数且不超过最大值</span><br><span class="line">                       int s = workers.size();</span><br><span class="line">                       if (s &gt; largestPoolSize)</span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                       workerAdded = true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行</span><br><span class="line">               if (workerAdded) &#123;</span><br><span class="line">                   //执行ThreadPoolExecutor的runWoker方法</span><br><span class="line">                   t.start();</span><br><span class="line">                   workerStarted = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 线程启动失败，则从wokers中移除w并递减wokerCount</span><br><span class="line">           if (! workerStarted)</span><br><span class="line">               // 递减wokerCount会触发tryTerminate方法</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       return workerStarted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="工作线程-runWorker流程"><a href="#工作线程-runWorker流程" class="headerlink" title="工作线程-runWorker流程"></a>工作线程-runWorker流程</h4><p><strong>工作线程</strong>:线程池创建线程时,会将线程封装成工作线程Worker,Worker在执行完任务后,还会循环获取工作队列里的任务来执行.我们可以从Worker类的run()方法里看到这点</p>
<p><code>Worker</code>类中run方法会调用runWoker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  worker 线程启动后调用,while 循环(即自旋!)不断从等待队列获取任务并执行</span><br><span class="line">//  worker 初始化时，可指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span><br><span class="line"> final void runWorker(Worker w) &#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        // 该线程的第一个任务(若有)</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = null;</span><br><span class="line">        // 允许中断</span><br><span class="line">        w.unlock(); // allow interrupts</span><br><span class="line">        boolean completedAbruptly = true;</span><br><span class="line">        try &#123;</span><br><span class="line">         // 循环调用 getTask 获取任务</span><br><span class="line">            while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                 // 若线程池状态大于等于 STOP，那么意味着该线程也要中断</span><br><span class="line">                   /**</span><br><span class="line">                    * 若线程池STOP，请确保线程 已被中断</span><br><span class="line">                    * 如果没有，请确保线程未被中断</span><br><span class="line">                    * 这需要在第二种情况下进行重新检查，以便在关中断时处理shutdownNow竞争</span><br><span class="line">                    */</span><br><span class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                try &#123;</span><br><span class="line">                // 这是一个钩子方法，留给需要的子类实现</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                    // 执行任务</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; throw x;</span><br><span class="line">                    &#125; catch (Error x) &#123;</span><br><span class="line">                        thrown = x; throw x;</span><br><span class="line">                    &#125; catch (Throwable x) &#123;</span><br><span class="line">                        thrown = x; throw new Error(x);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    task = null;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">                // 到这里，需要执行线程关闭</span><br><span class="line">                // 1. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭</span><br><span class="line">                // 2. 任务执行过程中发生了异常</span><br><span class="line">                //    第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中说</span><br><span class="line">                //    第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="getTask流程"><a href="#getTask流程" class="headerlink" title="getTask流程"></a>getTask流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 此方法有三种可能</span><br><span class="line">// 1. 阻塞直到获取到任务返回。默认 corePoolSize 之内的线程是不会被回收的，它们会一直等待任务</span><br><span class="line">// 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span><br><span class="line">// 3. 如果发生了以下条件，须返回 null</span><br><span class="line">//     池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span><br><span class="line">//     线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span><br><span class="line">//     线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span><br><span class="line">    private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        // 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span><br><span class="line">         </span><br><span class="line">                    // 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    // 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null</span><br><span class="line">                    // 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？</span><br><span class="line">                    // 换句话说，返回 null 意味着关闭线程。</span><br><span class="line">                    // 那是因为有可能开发者调用了 setMaximumPoolSize 将线程池的 maximumPoolSize 调小了</span><br><span class="line">                </span><br><span class="line">                    // 如果此 worker 发生了中断，采取的方案是重试</span><br><span class="line">                    // 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span><br><span class="line">                    // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br><span class="line">                    // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // Check if queue empty only if necessary.</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            // CAS 操作，减少工作线程数</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            // Are workers subject to culling?</span><br><span class="line">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">                if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    return null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                if (r != null)</span><br><span class="line">                    return r;</span><br><span class="line">                timedOut = true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            // 如果此 worker 发生了中断，采取的方案是重试</span><br><span class="line">                        // 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span><br><span class="line">                        // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span><br><span class="line">                        // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span><br><span class="line">                timedOut = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Worker执行流程：</p>
<p><img src="/images/workerProcess.png" alt=""></p>
<h3 id="线程池使用的缓存队列-workQueue"><a href="#线程池使用的缓存队列-workQueue" class="headerlink" title="线程池使用的缓存队列(workQueue)"></a>线程池使用的缓存队列(workQueue)</h3><p>缓冲队列的长度决定了能够缓冲的最大数量，缓冲队列有三种通用策略：</p>
<ol>
<li>直接提交</li>
<li>无界队列</li>
<li>有界队列</li>
</ol>
<h4 id="直接提交-SynchronousQueue"><a href="#直接提交-SynchronousQueue" class="headerlink" title="直接提交(SynchronousQueue)"></a>直接提交(SynchronousQueue)</h4><p>工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。 </p>
<p>在此，如果不存在可用于立即运行任务的线程，则把任务加入队列将失败，因此会构造一个新的线程。</p>
<p>此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; </p>
<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>首先SynchronousQueue是无界的，也就是说他存储任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。</p>
<p>使用如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(   </span><br><span class="line">                2, 3, 30, TimeUnit.SECONDS,    </span><br><span class="line">                new  SynchronousQueue&lt;Runnable&gt;(),    </span><br><span class="line">                new RecorderThreadFactory(&quot;CookieRecorderPool&quot;),    </span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></p>
<p>假设当前核心线程已经有2个正在运行:</p>
<ol>
<li>此时来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。</li>
<li>又来了一个任务（B），且核心2个线程还没有忙完。接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。</li>
<li>此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程”，所以必然会新建一个线程来运行这个任务。</li>
<li>但是如果这三个任务都还没完成，继续来了一个任务，queue中无法插入（任务A还在queue中），而线程数达到了maximumPoolSize，所以只好执行异常策略了。 </li>
</ol>
<p>为了避免这种情况:，所以在使用SynchronousQueue通常要求maximumPoolSize是无界的（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁</p>
<h4 id="无界队列-LinkedBlockingQueue"><a href="#无界队列-LinkedBlockingQueue" class="headerlink" title="无界队列(LinkedBlockingQueue)"></a>无界队列(LinkedBlockingQueue)</h4><p>使用无界队列（例如 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时，新任务将在队列中等待。这样，创建的线程数量就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）</p>
<p>当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; </p>
<h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><p>拿newFixedThreadPool来说:</p>
<ol>
<li>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队</li>
<li>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程</li>
<li>正常情况下当无法加入队列时就创建新的线程，但无界队列不会出现无法加入队列的情况(资源耗尽另算)。换句说，永远也不会触发产生新的线程！线程数一直都是corePoolSize大小。忙完当前的线程，就从队列中拿任务开始运行。如果任务运行的时长比较长，而添加任务的速度远远超过处理任务的速度，任务队列就会疯长，任务内存很快就会爆掉</li>
</ol>
<h4 id="有界队列-ArrayBlockingQueue"><a href="#有界队列-ArrayBlockingQueue" class="headerlink" title="有界队列(ArrayBlockingQueue)"></a>有界队列(ArrayBlockingQueue)</h4><p>当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。</p>
<p>队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量.</p>
<h5 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h5><p>这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。</p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new ThreadPoolExecutor(  </span><br><span class="line">            2, 4, 30, TimeUnit.SECONDS,   </span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(2),   </span><br><span class="line">            new RecorderThreadFactory(&quot;CookieRecorderPool&quot;),   </span><br><span class="line">            new ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></p>
<p>假设，所有的任务都永远无法执行完:</p>
<ol>
<li>首先来的A,B直接运行</li>
<li>如果来了C,D，他们会被放到queue中</li>
<li>如果接下来再来E,F，则增加线程运行E，F。最大线程数是4</li>
<li>但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理</li>
</ol>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程池:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">              int maximumPoolSize,</span><br><span class="line">              long keepAliveTime,</span><br><span class="line">              TimeUnit unit,</span><br><span class="line">              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">       // threadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</span><br><span class="line">       this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">               Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>各个参数含义：</p>
<ul>
<li><p>corePoolSize： 线程池基本大小，核心线程池大小，活动线程小于corePoolSize则直接创建，大于等于则先加到workQueue中，队列满了才创建新的线程。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p>
</li>
<li><p>maximumPoolSize：最大线程数，超过就reject；线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</p>
</li>
<li><p>keepAliveTime：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率(创建线程的开销比较大)</p>
</li>
<li><p>unit：线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）</p>
</li>
<li><p>workQueue：工作队列，线程池中的工作线程都是从这个工作队列源源不断的获取任务进行执行</p>
</li>
</ul>
<h4 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h4><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析:</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<ul>
<li>任务的优先级：高、中和低</li>
</ul>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行<br>如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<ul>
<li>任务的执行时间：长、中和短</li>
</ul>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
<ul>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接</li>
</ul>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。<br>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有时候我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://cmsblogs.com/?p=2444" target="_blank" rel="noopener">J.U.C之线程池</a></li>
<li><a href="https://juejin.im/post/5a37944ef265da432b4aec03" target="_blank" rel="noopener">线程池使用总结</a></li>
<li><a href="https://blog.csdn.net/fuyuwei2015/article/details/72758179" target="_blank" rel="noopener">java线程池原理及分析</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1124439" target="_blank" rel="noopener">线程池源码分析-使用总结</a></li>
<li><a href="https://blog.csdn.net/pozmckaoddb/article/details/51478017" target="_blank" rel="noopener">java线程池拒绝策略</a></li>
<li><a href="https://blog.csdn.net/xx326664162/article/details/51701508" target="_blank" rel="noopener">java线程池原理和队列详解</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/15/并发/ThreadLocal详解/" rel="next" title="ThreadLocal详解">
                <i class="fa fa-chevron-left"></i> ThreadLocal详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/28/并发/CAS解析/" rel="prev" title="CAS解析">
                CAS解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">Leo Hao</p>
            <p class="site-description motion-element" itemprop="description">勿在浮沙筑高台</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable和Future"><span class="nav-number">2.</span> <span class="nav-text">Callable和Future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Callable"><span class="nav-number">2.1.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Future"><span class="nav-number">2.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">2.3.</span> <span class="nav-text">FutureTask</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池实现架构"><span class="nav-number">3.</span> <span class="nav-text">线程池实现架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Executor"><span class="nav-number">3.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorService"><span class="nav-number">3.2.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractExecutorService"><span class="nav-number">3.3.</span> <span class="nav-text">AbstractExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledExecutorService"><span class="nav-number">3.4.</span> <span class="nav-text">ScheduledExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">3.5.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池实现原理"><span class="nav-number">4.</span> <span class="nav-text">线程池实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池处理流程"><span class="nav-number">4.1.</span> <span class="nav-text">线程池处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#线程池饱和策略"><span class="nav-number">4.1.1.</span> <span class="nav-text">线程池饱和策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">5.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ctl变量"><span class="nav-number">5.1.</span> <span class="nav-text">ctl变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键的类成员"><span class="nav-number">5.2.</span> <span class="nav-text">关键的类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execute流程"><span class="nav-number">5.3.</span> <span class="nav-text">execute流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addWorker流程"><span class="nav-number">5.4.</span> <span class="nav-text">addWorker流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作线程-runWorker流程"><span class="nav-number">5.5.</span> <span class="nav-text">工作线程-runWorker流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getTask流程"><span class="nav-number">5.5.1.</span> <span class="nav-text">getTask流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池使用的缓存队列-workQueue"><span class="nav-number">6.</span> <span class="nav-text">线程池使用的缓存队列(workQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#直接提交-SynchronousQueue"><span class="nav-number">6.1.</span> <span class="nav-text">直接提交(SynchronousQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用示例"><span class="nav-number">6.1.1.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无界队列-LinkedBlockingQueue"><span class="nav-number">6.2.</span> <span class="nav-text">无界队列(LinkedBlockingQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用示例-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有界队列-ArrayBlockingQueue"><span class="nav-number">6.3.</span> <span class="nav-text">有界队列(ArrayBlockingQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用示例-2"><span class="nav-number">6.3.1.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的使用"><span class="nav-number">7.</span> <span class="nav-text">线程池的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程池"><span class="nav-number">7.1.</span> <span class="nav-text">创建线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合理的配置线程池"><span class="nav-number">7.2.</span> <span class="nav-text">合理的配置线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo Hao</span>

  
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
