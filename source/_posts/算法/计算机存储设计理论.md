---
title: 计算机存储设计理论
date: 2024-05-24 17:51:08
tags: 存储
categories: 算法
---

### 概述

不同的数据库存储系统都会设计不同的索引结构来优化查询/写入效率， 在讨论这些结构之前， 我们先从头回顾一下计算机存储的一些设计

#### 计算机存储分级设计

计算机的存储器设计采用了一种分层次的结构。寄存器、高速缓存、主存和硬盘，从顶至底，这些存储器的速度逐级递减而容量逐级递增，并且伴随越来越低的价钱，如图

![](/images/computer/storage-level.png)


在现代计算机里面, 上面的存储实际上分为CPU(寄存器，高速缓存L1、L2、L3)、内存、硬盘(SSD,HDD)


#### IO 局部性原理

局部性原理（Principle of Locality）指在程序执行过程中，倾向于访问某些局部特定的数据或指令，而不是随机地访问整个内存空间。通常分为两种类型：时间局部性和空间局部性。

- 时间局部性（Temporal Locality）：如果一个数据被访问，那么在近期内它很可能会被再次访问。例如，在一个循环中反复使用的变量
- 空间局部性（Spatial Locality）：如果一个数据项被访问，那么在其附近的数据项也很可能会被访问。例如，顺序执行的指令和顺序访问的数组元素


#### page cache

![](/images/computer/pagecache.png)

系统调用的read/write和底层的硬盘读写之间存在一层I/O缓存（Kernel buffer cache），在Linux中称为Page Cache，它利用了局部性原理来提高系统的I/O性能： 
1. 当一个数据页被从硬盘读取到内存时，它被存储在 `Page Cache` 中。如果这个数据页在近期内被再次访问（时间局部性），那么可以直接从 Page Cache 中读取，而无需再次访问硬盘。
2. 当一个数据页被读取时，操作系统通常会预读取一些附近的数据页（空间局部性），并将它们也存储在 `Page Cache` 中，以便后续的访问。


Page Cache的大小是根据当前系统的可用内存和工作负载动态调整的，此外还会通过页面置换算法如 LRU 定期淘汰旧的数据页。Page Cache可以大大减少硬盘I/O，从而提高系统的性能。

Page Cache支持写回（write-back）和写穿（write-through）两种策略：
1. 在写回策略中，当程序写入数据时，数据首先被写入Page Cache，然后在适当的时机被写入硬盘。
2. 在写穿策略中，数据同时被写入Page Cache和硬盘。

Linux下默认使用 `write-back` 策略，即文件操作的写只写到 Page Cache 就返回。Page Cache中被修改的内存页称之为`脏页（Dirty Page）`，脏页在特定的时候被一个叫做`pdflush(Page Dirty Flush)`的内核线程写入硬盘，写入的时机和条件如下：
1. 当空闲内存低于一个特定的阈值时
2. 当脏页在内存中驻留时间超过一个特定的阈值时
3. 用户进程调用sync、fsync、fdatasync系统调用时

#### 顺序 IO

顺序I/O（Sequential I/O）是一种数据访问模式，其中数据按照连续的顺序进行读取或写入。这与随机I/O（Random I/O）形成对比，随机I/O是指数据的访问位置在存储设备上是随机分布的。
顺序I/O的性能之所以高，主要是因为它能够最大化利用存储设备的局部性原理，并且减少了寻道时间和旋转延迟：
1. 局部性原理：在顺序I/O中，数据是连续读取或写入的，Page Cache可以将文件的连续数据块缓存在内存中，以提供快速的连续读取。此外Page Cache可以将内存中缓存的连续数据，比如按页大小批次刷新到硬盘。这样可以减少频繁的硬盘写入操作。
2. 减少寻道时间和旋转延迟：寻道操作指磁头移动到硬盘的正确轨道的过程，旋转延迟指磁头等待硬盘旋转到正确位置的时间。在顺序I/O中，由于数据是连续存储的，因此可以大大减少寻道时间和旋转延迟，从而提高I/O性能。


内存访问速度和硬盘访问速度的对比结果。简单总结下：

1. 硬盘访问时间：寻道时间+旋转时间+传输时间：
2. 硬盘随机I/O ≪ 硬盘顺序I/O ≈ 内存随机I/O≪ 内存顺序I/O。
3. 机械硬盘和固态硬盘构成：
    - 机械硬盘：电磁存储，通过电磁信号转变来控制读写，磁头机械臂移动；
    - 固态硬盘：半导体存储，用固态电子存储芯片阵列、由控制单元和存储单元组成，内部由闪存颗粒组成。速度较快

访问速度对比:
![](/images/computer/sequential-io-speed.png)

### 存储引擎

存储引擎是存储系统的发动机，决定了存储系统的性能和功能。存储引擎主要负责数据如何读写，包括读多写少和写多读少场景，读取操作又分为随机读取和顺序扫描。目前常见的存储引擎使用的存储数据结构主要有：

1. 哈希表（Hash Table）：支持随机读取，但不支持顺序扫描，对应键值 (Key-Value) 存储系统 
2. B 树（Balance Tree）: 适用于那些需要快速查找、插入和删除关键字的场景，如文件系统、数据库等。
3. B+树（Balance+ Tree）：支持随机读取和顺序扫描，读多写少场景，用于那些需要高效进行范围查询和顺序访问的场景，如数据库、索引等
4. LSM树（Log-Structured Merge Tree）：支持随机读取

#### Hash table

mysql 在指定索引的时候可以使用 `B+Tree` 或 `HashTable`。

由于哈希映射关系，哈希表在查找单条数据时候，能保证O(1)的时间复杂读。但哈希表在范围查询和排序遍历时候，只能进行全表扫描并依次判断是否满足条件，这样就会让性能影响非常大， 所以不是特殊场景(譬如 Memory 引擎)不会选择 HashTable 当做底层存储结构


#### B Tree

相较于 HashTable 查找的平均时间复杂度比O(1)稍慢的是O(logn)，这类数据结构有 **平衡二叉树(AVL Tree)**，**红黑树(RB Tree)**、**B树(B Tree)**、**B+树(B+ Tree)**等。此类型结构天然就支持排序、范围查找操作。

以平衡二叉树为例，一般情况下查询性能非常好，但平衡二叉树单个节点只能保存一个数据，因此当覆盖大量数据时候，平衡二叉树的树高度很高。这意味着当需要通过遍历获取存储在硬盘上的数据时候，需要更多次的I/O操作。硬盘读取时间远远超过数据在内存中比较的时间，这将导致程序大部分时间会阻塞在硬盘 I/O 上。

为了降低树的高度， 减少 I/O 操作， 可以选择多叉树。