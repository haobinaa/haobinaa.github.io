---
title: 树
date: 2017-12-26 18:22:38
tags: 算法
categories: 算法
---
### 树的基本特性

1. 每个节点可以有多个子节点(children)，而该节点是相应子节点的父节点(parent)
2. 树有一个没有父节点的节点，称为根节点(root) 
3. 没有子节点的节点称为叶节点(leaf)
4. 两个具有相同父节点的节点称为兄弟节点
5. 一个节点的子节点以及子节点的后代称为该节点的子树 (subtree)

- 树的高度:从根节点开始（其深度为1）自顶向下逐层累加的
- 树的深度:从根节点开始（其高度为0）自顶向下逐层累加的


#### 二叉树
二叉树(binary)是一种特殊的树，它是每个节点最多有两个子树的树结构，通常子树被称作是 "左子树" 和 "右子树"，二叉树常用于实现二叉搜索树和二叉堆。

#### 完全二叉树
 
若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边.即除了最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点

![](https://upload-images.jianshu.io/upload_images/1630488-79802447d1d63c9b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/567)

说到完全二叉树，堆是一种近似完全二叉树的数据结构，但是具有根节点大于子节点(大顶堆)或小于子节点(小顶堆)的性质



#### 满二叉树
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树被称之为满二叉树

满二叉树一定是完全二叉树，完全二叉树不一定满二叉树

![](https://upload-images.jianshu.io/upload_images/1630488-d87b70e0df31dc74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/534)

#### 二叉搜索树(Binary Search Tree)

二叉搜索树是一种特殊的二叉树，也可以称为二叉排序树，二叉查找树。除了具有二叉树的基本性质外，它还具备：

1. 树中每个节点最多有两个子树，通常称为左子树和右子树
2. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
3. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
4. 它的左右子树仍然是一棵二叉搜索树 (recursive)


#### 二叉树的性质
- 在二叉树中，第i层的结点总数不超过2^i-1
- 深度为h的二叉树最多有2^h-1个结点(h>=1)，最少有h个结点
- 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，
  则N0=N2+1
- 具有n个结点的完全二叉树的深度为（log2n）+1
- 如果按照层次顺序存储完全二叉树，若i为节点编号，那么有：
    - 父节点编号为 i/2
    - 左子节点为 2*i
    - 右子节点为 2*i+1




### 基本操作

#### 定义基本的数据结构
``` 
class TreeNode<E extends Comparable<E>>{
    private E data;
    private TreeNode<E> left;
    private TreeNode<E> right;
    TreeNode(E theData){
        data = theData;
        left = null;
        right = null;
    }
}
public class BinarySearchTree<E extends Comparable<E>>{
    private TreeNode<E> root = null;
}
```

#### 树的遍历
- 中序遍历(左根右)
``` 
public void inOrder(TreeNode<E> cursor){
    if(cursor == null) return;
    inOrder(cursor.getLeft());
    System.out.println(cursor.getData());
    inOrder(cursor.getRight());
}
```
- 前序遍历(根左右)
``` 
public void preOrder(TreeNode<E> cursor){
    if(cursor == null) return;
    System.out.println(cursor.getData());
    inOrder(cursor.getLeft());
    inOrder(cursor.getRight());
}
```
- 后序遍历(左右根)
``` 
public void postOrder(TreeNode<E> cursor){
    if(cursor == null) return;
    inOrder(cursor.getLeft());
    inOrder(cursor.getRight());
    System.out.println(cursor.getData());
}
```

#### 树的搜索
``` 
public boolean searchNode(TreeNode<E> node){
    TreeNode<E> currentNode = root;
    while(true){
        if(currentNode == null){
            return false;
        }
        if(currentNode.getData().compareTo(node.getData()) == 0){
            return true;
        }else if(currentNode.getData().compareTo(node.getData()) < 0){
            currentNode = currentNode.getLeft();
        }else{
            currentNode = currentNode.getRight();
        }
    }
}
```

#### 插入节点

步骤：

1. 递归地去查找该二叉树，找到应该插入的节点
2. 若当前的二叉查找树为空，则插入的元素为根节点
3. 若插入的元素值小于根节点值，则将元素插入到左子树中
4. 若插入的元素值不小于根节点值，则将元素插入到右子树中

``` 
public void insertNode(TreeNode<E> node){
    TreeNode<E> currentNode = root;
    if(currentNode == null){
        root = node;
        return;
    }else{
        while(true){
            if(node.getData().compareTo(currentNode.getData()) < 0){
                if(currentNode.getLeft() == null){
                    break;
                }else{
                    currentNode = currentNode.getLeft();
                }
            }else if(node.getData().compareTo(currentNode.getData()) > 0){
            
                if(currentNode.getRight() == null){
                    break;
                }else{
                    currentNode = currentNode.getRight();
                }
            }
        }   
    }
    if(node.getData().compareTo(currentNode.getData()) < 0){
        currentNode.setLeft(node);
    }else if(node.getData().compareTo(currentNode.getData()) > 0){
        currentNode.setRight(node);
    }
}
```

#### 删除节点

首先需要搜索该节点，然后可以分为以下四种情况进行讨论：

##### 1.如果找不到该节点，那么什么都不用做
![](https://upload-images.jianshu.io/upload_images/1630488-9a36f1b007b72502.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/611)

##### 2.如果被移除的元素在叶节点(no children)：那么直接移除该节点，并且将父节点原本指向该位置改为 null (如果是根节点，那就不用修改父节点指向位置)

删除元素6：
![](https://upload-images.jianshu.io/upload_images/1630488-b4670854b1fed172.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/611)

##### 3.如果删除的元素只有一个儿子(one child)：那么也很简单，直接删除该节点，并且将父节点原本指向的位置改为该儿子 (如果是根节点，那么该儿子成为新的根节点)

![](https://upload-images.jianshu.io/upload_images/1630488-0eb4fc709c1316d4.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/611)

##### 4.如果删除的元素有两个儿子，那么可以取左子树中最大元素或者右子树中最小元素进行替换，然后将最大元素最小元素原位置置空

![](https://upload-images.jianshu.io/upload_images/1630488-606b485509ba620b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/611)


### 平衡二叉树

当二叉树在特定情况下，所有的节点都在一边，就退化成了一个线性的结构，效率十分低下，如图：
![](https://upload-images.jianshu.io/upload_images/1630488-14d4db6560c2868d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)


这个时候时间复杂度就从logn退化到了n，我们为了保持树的效率，就做了一些限制，定义了一种二叉树的变种：平衡二叉树


平衡二叉树：
1. 是具二叉树
2. 它的左子树和右子树都是平衡二叉树
3. 左子树和右子树的高度之差之差的绝对值不超过1


#### 构造平衡二叉树
平衡二叉树是在构造二叉排序树的过程中，每当插入一个新结点时，首先检查是否因插入新结点而破坏了二叉排序树的平衡性，若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。具体步骤如下：
1. 每当插入一个新结点，从该结点开始向上计算各结点的平衡因子，即计算该结点的祖先结点的平衡因子，若该结点的祖先结点的平衡因子的绝对值均不超过1，则平衡二叉树没有失去平衡，继续插入结点
2. 若插入结点的某祖先结点的平衡因子的绝对值大于1，则找出其中最小不平衡子树的根结点
3. 判断新插入的结点与最小不平衡子树的根结点的关系，确定是哪种类型的调整
4. 如果是LL型或RR型，只需应用扁担原理旋转一次，在旋转过程中，如果出现冲突，应用旋转优先原则调整冲突；如果是LR型或LR型，则需应用扁担原理旋转两次，第一次最小不平衡子树的根结点先不动，调整插入结点所在子树，第二次再调整最小不平衡子树，在旋转过程中，如果出现冲突，应用旋转优先原则调整冲突
5. 计算调整后的平衡二叉树中各结点的平衡因子，检验是否因为旋转而破坏其他结点的平衡因子，以及调整后的平衡二叉树中是否存在平衡因子大于1的结点

    
### 参考资料
- [数据结构-树](https://www.jianshu.com/p/45661b029292)
- [算法](#)