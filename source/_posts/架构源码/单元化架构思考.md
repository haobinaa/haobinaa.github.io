---
title: 单元化架构思考
date: 2024-02-20 11:31:46
tags:
categories: 架构
---

### 架构演进

#### 单体架构

单体架构最初就是打一个大包， 将UI、后台服务都打在一起。 早期的 ASP、JSP、PHP 技术体系中非常流行。
随着业务的发展， 架构的复杂性、流量的增长， 单体架构的逐渐产生了一些单点瓶颈:
1. 应用数据库竞争
2. 应用瓶颈
3. 数据库瓶颈

#### 应用数据库竞争

最开始应用和数据库部署在同一台机器很容易产生资源竞争  

所以第一步就是把程序和数据库分开部署

#### 应用瓶颈-集群部署

当流量增多后， 单应用部署已经不能满足服务要求了。
应用程序内部的性能调优外，从架构层面可以采用**集群化部署**模式，将大量的业务流量通过负载均衡服务来分流到多台应用服务器上处理。常见的负载均衡有F5，Nginx和云上的各种LB服务。


#### 数据库扩容-读写分离
当应用扩容后， 压力就到了数据库， 在大部分场景下都是读多写少， 数据库第一步优化都是**读写分离**， 开启数据库的主从复制功能， 利用从库来分担度流量

#### 数据库垂直拆分

随着业务的持续增长，主库已经难以支撑所有的写请求，这个阶段优先需要做的是数据库的**垂直切分**

譬如电商系统会按照业务领域拆成: 订单库、商品库、 用户库等多个数据库， 这样写请求就会按照各自的业务量分流到了不同的库上。不过这种拆分可能会引起分布式事务产生。如果存在一次事务跨了多个业务域的数据库，那就需要考虑多个数据库间的数据一致性问题。我们可以借助分布式数据库的产品能力解决，或在应用层引入分布式事务框架解决，也可以通过消息中间件实现最终一致性，取决于不同场景下的业务接受度。

备注: 这一步通常会将应用一起按照领域进行拆分(服务化)

#### 数据库水平拆分


在系统按领域切分之后，如果某一领域内的业务量依然大到主库无法承载。那么接下去就需要在垂直拆分的数据库上再进行一次**水平拆分**。水平拆分可以将落到一台主库的压力分摊到多个分库上。这个阶段设计时需要注意数据路由和扩容场景：

1. 数据一旦被按照一个维度进行了分库，那应用在请求时就需要在请求中带上该维度的值(通常称为分片键)，进行路由判断，识别该数据在哪个分库上；

2. 其次是扩容问题，假如当前为10个分库，一开始的路由算法为 hash(客户号)%10，后面扩容到12个分库，那计算规则就要变成 hash(客户号)%12。这样，所有分库上的数据都需要按照新的路由规则重新计算并进行数据迁移，这个过程称为“数据重分布”，成本和代价都很高。建议在设计阶段提前与各方约定好路由规则和扩容策略。

#### 应用垂直拆分

在数据库按照业务领域垂直拆分的基础上， 一般应用也会垂直拆分(如上述例子， 会拆分成订单服务、商品服务、用户服务)， 不同领域的业务连到各自领域的数据库上。

到这个阶段，最初的系统已经被按照不同业务领域，从设计到落地都实现了解耦。基于这种架构已经可以初步支持不同模块的独立迭代与演进，很贴近我们现在所了解的“微服务”架构。

#### 应用SOA

把一个单体应用拆分为多个子应用时，随之而来的问题是这几个子应用间的通讯问题。在微服务架构之前，银行普遍采用消息总线(ESB)来做多个系统间的"衔接"。它就像一根通道，集成不同的应用、不同的协议，承担消息解释与路由职责，实现互联互通。属于早期分布式的经典架构。

微服务架构和SOA架构同样都是面向服务的架构设计。微服务更强调了去中心化思想，而ESB作为全行的消息总线在一定程度上是形成了单点和瓶颈。微服务架构就是从本质上去掉了ESB，通过注册中心来实现服务发现能力。以发布和订阅服务目录的方式，让应用间通过服务目录来实现点对点的直连通讯。


### 微服务架构

#### 微服务架构需要具备的能力

SOA 架构已经与我们熟悉的微服务架构相似了： 业务按领域拆分，模块间相互解耦，具备独立演进的能力。

从单体应用往分布式架构演进的过程来看， 可以得出一个微服务架构所需要的能力:
1. 由于系统被拆成多个服务，所以需要具备：服务注册和相互发现的能力(**注册中心**)
2. 采用分布式部署后，多个服务间需要具备：统一的配置发布与热生效能力(**配置中心**)
3. 系统拆分后有多个应用端点，对外需要：统一入口来收敛访问端点并提供统一鉴权、路由转发等能力(**API网关**)
4. 为了提供可用性，采用了集群部署模式，所以需要具备：应用实例的故障发现与隔离能力(**注册中心-健康检查**)
5. 集中式系统内部通过内存地址引用可以直接调用，在分布式架构下则会变成网络调用，因此需要具备：点对点通讯能力，由于服务都是集群形态，调用还需要支持软负载均衡的能力(**服务治理或者说是RPC框架**)
6. 考虑到标准服务器的故障率、大量网络通信带来的稳定因素，以及可能存在的突发大规模流量等场景需求，分布式架构需要具备：服务的限流、熔断和降级等处置能力(**限流、熔断、降级**)
7. 由于多模块间调用会导致系统请求链路的增长，降低了系统的性能与不稳定性，增加了运维复杂度，因此需要增加：全链路可观测与故障节点定位的能力(**链路追踪或者说APM**)
8. 应用拆分部署后，由于一次交易变成了多进程访问数据库，从而产生事务一致性问题，需要具备：分布式事务能力(**分布式事务方案**)

在分布式架构下， 数据库应该具备的能力:
1. 扩展数据库TPS, 读写分离
2. 数据的水平拆分，数据库分片(中间件或者分布式数据库)
3. 由于数据库的拆分(水平或垂直)， 整体需要具备分布式事务以及查询聚合(OLAP)


#### 大型微服务部署架构

对于一些有一定规模并且对稳定性、可用性有要求的业务， 一般都在集群化的基础上再进行扩展: 即**多活架构**

对于大部分有异地多活的业务来说， **两地三中心**是一个标准的选择， 即: 同城为双活，异地为灾备，一共三个数据中心

![](/images/microservice/2_3.png)

上图是一个标准的两地三中心部署架构， 流量从全局负载均衡(或DNS解析)进入到同城两个数据中心，到微服务网关层时， 网关通过注册中心获取目标服务的可用地址，基于软负载策略发起点对点调用。
应用在处理数据时，由于数据库主库是单边活(分布式数据库一样也是架构层面实现数据多点可用，而并非是一份数据在多点同时多活)，所以同城中心的应用有可能需要跨中心访问到另一个中心进行数据操作。

这个架构在极端情况下可能存在两个问题:
1. 应用服务之间的跨机房调用
2. 应用与数据库之间的跨机房调用


以目前的网络基础设施情况，同城内多个机房间的网络情况在大部分情况下稳定性和性能都是有保障的，50公里的延时一般都在1ms以下。这对于跨中心访问来说问题并不大，足以应对大部分普通场景.
当业务出于高峰期的时候， QPS在十万以上， 抖动和延时的问题就会对业务造成一定的影响， 在服务层面可以通过微服务框架的调度策略如就近路由等来避免， 但是在数据库层面就没办法完全避免了。

常见分布式架构
![](/images/microservice/distribute_arch.png)


### 单元化架构

#### 单元化架构简介

单元化架构就是把单元作为部署的基本单位，在全站所有机房中部署数个单元，每个机房里的单元数目不定，任意一个单元 都部署了系统所需的所有应用，数据则是全量数据按照某种维度划分后的一部分。

单元化架构希望在分布式架构上解决如下问题:
1. 异地场景下的访问延时问题，实现异地多活。
2. 单机房数据库连接限制问题，突破物理限制。
3. 容量预估和扩容复杂问题，按单元预估和扩容。

单元化架构的核心原则是单元化流量封闭，包含以下几点:
1. 核心业务是可分片的, 其中最重要的是数据层面的分片: 粒度合适、足够平均
2. 单元化架构下，服务仍然是分层的，不同的是每一层中的任意一个节点都属于且仅属于某一个单元，上层调用下层时，仅会选择本单元内的节点
3. 核心业务尽量自包含，调用尽量封闭。
4. 整个系统要面向逻辑分区设计，而不是物理部署


// todo 一张单元化架构图


#### 单元化架构基础术语

这里参考的是蚂蚁的定义， 不同的厂商有不同的叫法和实施细则。

- 单元: 应用层按照数据层相同的拆片维度，把整个请求链路收敛在一组服务器中，从应用层到数据层就可以组成一个封闭的单元。数据库只需要承载本单元的应用节点的请求，大大节省了连接数。 单元可以作为一个相对独立整体来挪动，甚至可以把部分单元部署到异地去
- 逻辑单元: 逻辑单元是单元化架构的基础，一个逻辑单元被称为一个 Zone。根据业务特点不同，您可以将系统部署在不同类型的逻辑单元中。有 3 种不同类型：RZone、GZone、CZone。
- GZone: 无法拆分的业务，如配置型的业务。数据库可以和 RZone 共享，多租户隔离，全局只有一组，可以配置流量权重。会被 RZone 依赖
- RZone: 核心业务和数据单元化拆分，拆分后分片均衡，单元内尽量自包含（调用封闭），拥有自己的数据，能完成所有业务。 一个可用区可以有多个 RZone
- CZone: 为了解决异地延迟问题而特别设计，适合读多写少且不可拆分的业务。 一般每个城市一套应用和数据，是 GZone 的快照，被 RZone 高频访问
- 路由规则: 单元化架构下的路由规则是一个 json 字符串，包含了路由信息、灾备信息、机房部署信息、灰度信息等，主要用于 http 请求转发、rpc 路由计算、msg 目标 Zone 计算、zdal 数据源连接、zcache 集群选择等
- Uid: 也叫 sharding key，指应用层和数据层的拆分维度，在 LHC(LDC Hybrid Cloud 单元化应用) 里可以指定 UID 分片与部署单元的映射关系。在实际 使用过程中 UID 可以对应着多种类型的数据，如用户 ID、交易流水，只要能映射到分片即可



### 参考资料
- [异地多活与单元化](https://magicliang.github.io/2020/09/02/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%E4%B8%8E%E5%8D%95%E5%85%83%E5%8C%96/)
- [蚂蚁单元化解决方案白皮书]
- [支付宝金融分布式单元化架构](https://www.sofastack.tech/blog/antgroup-yinboxue-fully-distributed-unitized-technology-architecture/)
