---
title: 分布式理论与分布式事务
date: 2019-03-28 18:16:38
tags:
categories: 架构
description: 分布式理论
---

## CAP理论

CAP理论又称为布鲁尔定理， 它指出对于一个分布式计算系统来说，不可能同时满足以下三点：
- 一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）
- 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
- 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择）


### Consistency 一致性

一致性指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以说的就是数据一致性

对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

三种一致性策略:
1. 对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性
2. 如果能容忍后续的部分或者全部访问不到，则是弱一致性。
3. 如果经过一段时间后要求能访问到更新后的数据，则是最终一致性

CAP中说，不可能同时满足的这个一致性指的是强一致性


### Availability 可用性

可用性指服务一直可用，而且是正常响应时间

对于一个分布式系统，可用性一般都是通过停机时间来衡量的(常说的是系统的可用性是几个9)

### Partition Tolerance 分区容错性

分区容错性指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

### CAP权衡

在分布式系统中，CAP三者目前是无法同时满足的，所以我们要在不同的业务场景中做不同的权衡

#### CA

这个情况基本上是不会选择的，因为分布式系统下，网络分区是一个必然的选项。如果要舍弃P，那就要舍弃分布式系统， 所以我们一般都是在CP和AP上做选择

#### CP

如果系统选择不要可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。

设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。

#### AP 

要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

我们这里说的舍弃一致性，其实舍弃的是强一致性，退而求其次保证最终一致性


## BASE理论

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性。

BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。

### 基本可用 Basically Available

基本可用指的是，系统出现了不可预知的故障，但还是能用，但相对于正常的系统来说：
1. 响应时间上的损失， 会比正常响应慢
2. 功能上的损失，高峰期间，采取一些措施，部分用户会得不到正常完整功能(限流、降级)

### 软状态 Soft State 

相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。

软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

### 最终一致性 Monotonic write consistency

上文的软状态只是一个中间状态，必须要有个时间期限，期限过后，应当保证所有副本保持数据一致性，从而达到最终一致性。这个期限取决于网络延时、系统负载、数据复制方案等


## 分布式事务

### 2PC(2 Phase Commitment Protocol) 两段式提交协议

2PC协议，分为两个阶段提交一个事务，通过协调者和各个参与者的配合，实现分布式一致性。

两个阶段指的是:
1. 第一阶段： 准备阶段
2. 提交阶段

#### XA规范

XA规范是一个分布式事务处理模型，包括:
- 应用程序(AP)
- 事务管理器(TM): 交易中间件等
- 资源管理器(RM): 关系数据库等
- 通信资源管理器(CRM): 消息中间件等

XA规范定义了交易中间件和数据库之间的接口规范，交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供。

#### 1.准备阶段

准备阶段分为三个步骤:
1. 事务询问：协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应
2. 执行事务：各参与者节点执行事务操作。如果本地事务成功，将Undo和Redo信息记入事务日志中，但不提交；否则，直接返回失败，退出执行。
3. 各个参与者向协调者反馈事务询问的响应:如果参与者成功执行了事务操作，那么就反馈给协调者 Yes响应，表示事务可以执行提交；如果参与者没有成功执行事务，就返回No给协调者，表示事务不可以执行提交

![](/images/arch/2pc.png)

#### 2.提交阶段

1. 发送提交请求： 协调者向所有参与者发出commit请求。
2. 事务提交： 参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后，释放整个事务执行期间占用的事务资源
3. 反馈事务提交结果： 参与者在完成事务提交之后，向协调者发送Ack信息
4. 事务提交确认： 协调者接收到所有参与者反馈的Ack信息后，完成事务

![](/images/arch/2pc-2.png)

中断事务的流程如下:
1. 发送回滚请求： 协调者向所有参与者发出Rollback请求
2. 事务回滚： 参与者接收到Rollback请求后，会利用其在提交阶段种记录的Undo信息，来执行事务回滚操作。在完成回滚之后，释放在整个事务执行期间占用的资源
3. 反馈事务回滚结果： 参与者在完成事务回滚之后，想协调者发送Ack信息
4. 事务中断确认： 协调者接收到所有参与者反馈的Ack信息后，完成事务中断。

![](/images/arch/2pc-3.png)

#### 两阶段提交的优缺点

优点： 原理简单，实现方便

缺点：
- 同步阻塞：在第二阶段提交过程中，所有节点都在等其他节点响应，无法进行其他操作，这种同步阻塞限制了分布式系统的性能
- 单点问题：协调者如果出现了问题，整个流程就无法进行
- 数据不一致：协调者向所有的参与者发送commit请求之后，发生了局部网络异常，或者是协调者在尚未发送完所有 commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求。这将导致严重的数据不一致问题。
- 容错性不好：如果在二阶段提交的提交询问阶段中，参与者出现故障，导致协调者始终无法获取到所有参与者的确认信息，这时协调者只能依靠其自身的超时机制，判断是否需要中断事务。显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败。

### 3PC

由于2PC存在的单点、阻塞等问题， 在2PC的基础上做了改进， 提出了三阶段提交， 与两阶段提交不同的是，三阶段提交有两个改动点。

1. 引入超时机制 - 同时在协调者和参与者中都引入超时机制
2. 在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的

![](/images/arch/3pc.png)

1. 第一阶段： CanCommit(询问阶段)
2. 第二阶段： PreCommit(预提交，锁定资源)
3. 第三阶段:  Do Commit(提交)

#### 1. Can Commit（询问)
 
 1. 事务询问： 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
 2. 响应反馈： 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态；否则反馈No。
 
#### 2. Pre Commit(预提交)

1. 发送预提交请求：协调者向所有参与者节点发出 preCommit 的请求，并进入 prepared 状态。
2. 事务预提交： 参与者受到 preCommit 请求后，会执行事务操作，对应 2PC 准备阶段中的 “执行事务”，也会 Undo 和 Redo 信息记录到事务日志中
3. 参与者反馈： 如果参与者成功执行了事务，就反馈 ACK 响应，同时等待指令：提交（commit） 或终止（abort）。

#### 3. Do Commit

1. 发送提交请求：协调者接收到各参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。
2. 事务提交： 参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
3. 响应反馈： 事务提交完之后，向协调者发送 ACK 响应。
4. 完成事务： 协调者接收到所有参与者的 ACK 响应之后，完成事务

协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务

1. 发送中断请求： 协调者向所有参与者发送 abort 请求。
2. 事务回滚： 参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源
3. 反馈结果： 参与者完成事务回滚之后，向协调者发送 ACK 消息。
4. 中断事务： 协调者接收到参与者反馈的 ACK 消息之后，完成事务的中断。

### TCC

TCC相较于XA(2PC或3PC)机制，解决了几个问题：
1. 解决了协调者单点问题， 由由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群
2. 同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性


一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务。务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。


![](/images/arch/tcc.png)

#### TCC过程

- Try: 
  - 完成所有业务检查(一致性)
  - 预留必须业务资源(准隔离性，冻结操作) 
- Confirm
  - 真正执行业务
  - 不作任何业务检查
  - 只使用Try阶段预留的业务资源 
  - Confirm操作要满足幂等性
- Cancel:
  - 释放Try阶段预留的业务资源
  - Cancel操作要满足幂等性
  
#### TCC总结

TCC事务的使用严格依赖业务人员写的代码来回滚和补偿，很复杂， 使用的场景也不是很多。主要是在支付、交易相关的强一致性场景。

### 本地消息表

本地消息表是eBay设计的一种最终一致性的分布式事务处理方案， 适用于不需要强一致性的场景。

![](/images/arch/transcation-message-table.png)


1. A 系统操作自己本地事务的时候，同时插入一个消息到消息表
2. 接着A系统把这个消息发送到MQ中
3. B系统接收到MQ中的消息，先写入B系统的消息表，然后执行事务，事务执行成功后，更新B系统和A消息表的状态。
4. A系统会定时扫描自己的消息表，如果有未处理的消息，将再次发送到mq让b系统处理

这种方案验证依赖于数据的消息表，在高并发场景下则不适用，数据库承受不了这么大的并发量

### 可靠消息最终一致性方案(MQ处理)

这种方案不需要本地消息表了， 直接基于MQ来实现事务， 例如RocketMQ就支持消息事务

第一阶段：上游应用执行业务并发送MQ消息

![](/images/arch/mq-transcation-1.png)

1. 上游应用发送待确认消息到可靠消息系统
2. 可靠消息系统保存待确认消息并返回
3. 上游应用执行本地业务
4. 上游应用通知可靠消息系统确认业务已执行并发送消息。

第二阶段：下游应用监听 MQ 消息并执行业务

![](/images/arch/mq-transcation-2.png)

1. 下游应用监听 MQ 消息组件并获取消息
2. 下游应用根据 MQ 消息体信息处理本地业务
3. 下游应用向 MQ
4. 确认消息被消费
5. 下游应用通知可靠消息系统消息被成功消费，可靠消息将该消息状态更改为已完成


这种方案依赖于一种可靠的消息队列，确保消息被成功消息


### 参考资料
- [分布式事务框架Fescar](https://juejin.im/post/5c9c30535188251e161868ea)
- [分布式事务](https://juejin.im/post/5b5a0bf9f265da0f6523913b)
- [TCC分布式事务](https://juejin.im/post/5bf201f7f265da610f63528a)
- [事务基础与分布式事务](https://www.ibm.com/developerworks/cn/cloud/library/cl-manage-cloud-transactions_1/index.html)
- [分布式理论BASE](https://juejin.im/post/5b2663fcf265da59a401e6f8)
- [2PC协议](https://juejin.im/post/5b2664446fb9a00e4a53136e)
- [3PC协议](https://juejin.im/post/5b26648e5188257494641b9f)
- [TCC型分布式事务原理和实现](https://my.oschina.net/fileoptions/blog/899991)
- [用MQ来保证分布式事务的最终一致性](https://www.cnblogs.com/linkstar/p/9784243.html)
