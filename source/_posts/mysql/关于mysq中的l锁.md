---
title: 关于mysql中的锁
date: 2019-11-28 21:54:48
tags: mysql
categories: mysql
---
### 并发事务带来的问题

并发事务访问相同记录可大致分为三种情况:
1. 读-读：即并发事务相继读取相同的记录。

读取操作不会影响记录，并不会引发问题，所以允许这种情况的发生

2. 写-写：即并发事务相继对相同的记录做出改动。

这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。

3. 读-写 或 写-读：也就是一个事务进行读取操作，另一个进行改动操作

种情况下可能发生`脏读`、`不可重复读`、`幻读`的问题。

> 注意: 幻读问题的产生是因为某个事务读了一个范围的记录，之后别的事务在该范围内插入了新记录，该事务再次读取该范围的记录时，可以读到新插入的记录

#### 加锁解决并发写(脏写)

并发事务写-写情况下，会导致`脏写`的问题，这个在任何一种隔离级别下都是不允许发生的，所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。

事务执行前是没有锁的，也就是说一开始是没有锁结构和记录进行关联的， 当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比方说事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：

![](/images/mysql/mysql-lock.png)

锁里面包含了很多信息，这里只展示两个重要信息的含义:
- `trx信息`：代表这个锁结构是哪个事务生成的。
- `is_waiting`：代表当前事务是否在等待

当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

在事务T1提交之前，另一个事务T2也想对该记录做改动，那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁，如：

![](/images/mysql/mysql-lock-wait.png)

在事务T1提交之后，就会把该事务生成的锁结构释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的is_waiting属性设置为false，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。

#### 解决脏读、不可重复读、幻读

- 方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁

`MVCC`就是通过生成一个`ReadView`，然后通过`ReadView`找到符合条件的记录版本（历史版本是由undo日志构建的），其实就像是在生成`ReadView`的那个时刻做了一次时间静止（保存了一个快照），查询语句只能读到在生成`ReadView之`前已提交事务所做的更改，在生成`ReadView`之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用`MVCC`时，读-写操作并不冲突

- 方案二: 读写操作都进行加锁

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行

显然`MVCC`方式下, `读-写`操作彼此并不冲突，性能更高，采用`加锁`方式的话，`读-写`操作彼此需要排队执行，影响性能。 但是有些特殊场景下，必须采用加锁的方式执行



### 锁定读



#### 一致性读

 事务利用`MVCC`进行的读取操作称之为`一致性读`，或者`一致性无锁读`，有的地方也称之为`快照读`。所有普通的`SELECT`语句（`plain SELECT`）在`READ COMMITTED`、`REPEATABLE READ`隔离级别下都算是`一致性读` 。 `一致性读`并不会对表中的任何记录做`加锁`操作，其他事务可以自由的对表中的记录做改动。 



#### 共享锁和独占锁

 对于`写-写`、`读-写`或`写-读`这些情况可能会引起一些问题 , 可以使用 `MVCC`或者`加锁`的方式来解决 。mysql中的锁分为两类:

- `共享锁`：`Shared Locks`，简称`S锁`。在事务要读取一条记录时，需要先获取该记录的`S锁`。
- `独占锁`：也称`排他锁`（`Exclusive Locks`），简称`X锁`。在事务要改动一条记录时，需要先获取该记录的`X锁`

`S锁`和`X锁`的兼容性如下：

| 兼容性 | X      | S      |
| ------ | ------ | ------ |
| x      | 不兼容 | 不兼容 |
| S      | 不兼容 | 兼容   |



####  锁定读的语句

在介绍`S`锁的时候说读取一条记录的时候需要获取一下该记录的`S`锁，这并不是绝对的。 有时候想在读取记录时就获取记录的`X锁`，来禁止别的事务读写该记录，为此`MySQL`提出了两种比较特殊的`SELECT`语句格式： 

1.  对读取的记录加`S锁`： ` SELECT ... LOCK IN SHARE MODE; `

 也就是在普通的`SELECT`语句后边加`LOCK IN SHARE MODE`，如果当前事务执行了该语句，那么它会为读取到的记录加`S锁`，这样允许别的事务继续获取这些记录的`S锁`（比方说别的事务也使用`SELECT ... LOCK IN SHARE MODE`语句来读取这些记录），但是不能获取这些记录的`X锁`（比方说使用`SELECT ... FOR UPDATE`语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的`X锁`，那么它们会阻塞，直到当前事务提交之后将这些记录上的`S锁`释放掉。 

2.  对读取的记录加`X锁`： ` SELECT ... FOR UPDATE; `

 也就是在普通的`SELECT`语句后边加`FOR UPDATE`，如果当前事务执行了该语句，那么它会为读取到的记录加`X锁`，这样既不允许别的事务获取这些记录的`S锁`（比方说别的事务使用`SELECT ... LOCK IN SHARE MODE`语句来读取这些记录），也不允许获取这些记录的`X锁`（比方也说使用`SELECT ... FOR UPDATE`语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的`S锁`或者`X锁`，那么它们会阻塞，直到当前事务提交之后将这些记录上的`X锁`释放掉。 



#### 写操作

 `写操作`就是`DELETE`、`UPDATE`、`INSERT` 三种。

- `DELETE`：

  对一条记录做`DELETE`操作的过程其实是先在`B+`树中定位到这条记录的位置，然后获取一下这条记录的`X锁`，然后再执行`delete mark`操作。我们也可以把这个定位待删除记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。

- `UPDATE`：

  在对一条记录做`UPDATE`操作时分为三种情况：

  - 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。
  - 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护。
  - 如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了。

- `INSERT`：

  一般情况下，新插入一条记录的操作并不加锁，`InnoDB`通过一种称之为`隐式锁`的东西来保护这条新插入的记录在本事务提交前不被别的事务访问

### 表锁

针对于记录的锁称之为行锁， 对一条记录加锁影响的也只是这条记录。 一个事务在表级别进行加锁被称之为`表锁`，对一个表加锁影响整个表中的记录 。 表加的锁也可以分为`共享锁`（`S锁`）和`独占锁`（`X锁`）： 

- 给表加`S锁`：

  如果一个事务给表加了`S锁`，那么：

  - 别的事务可以继续获得该表的`S锁`
  - 别的事务可以继续获得该表中的某些记录的`S锁`
  - 别的事务不可以继续获得该表的`X锁`
  - 别的事务不可以继续获得该表中的某些记录的`X锁`

- 给表加`X锁`：

  如果一个事务给表加了`X锁`（意味着该事务要独占这个表），那么：

  - 别的事务不可以继续获得该表的`S锁`
  - 别的事务不可以继续获得该表中的某些记录的`S锁`
  - 别的事务不可以继续获得该表的`X锁`
  - 别的事务不可以继续获得该表中的某些记录的`X锁`

  这里就会产生两个问题:

  1. 如果要对整个表加`S锁`，就要先确认这个表里面没有任何记录获取了`X锁`，如果有获取了`X锁`的记录，需要等到`X锁`释放后才能对整个表加`S锁`
  2. 如果要对整个表加`X锁`，就要先确认这个表中没有记录获取了`X锁`和`S锁`.

  在加表锁的时候怎么确认没有记录被上了行锁，如果依次遍历检查每一行记录效率就太低了，`Innodb`提供了 `意向锁 `:

  -  意向共享锁（Intention Shared Lock)，简称`IS锁`。当事务准备在某条记录上加`S锁`时，需要先在表级别加一个`IS锁` 。在加`S锁`的时候需要先判断有没有`IX锁`,如果有需要等到`IX锁`被释放后才能加`S锁`
  -  意向独占锁(Intention Exclusive Lock)，简称`IX锁`。当事务准备在某条记录上加`X锁`时，需要先在表级别加一个`IX锁` 。同样加`X锁`的时候需要判断是否有`IS锁`或`IX锁`

   IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。 

### Mysql中的表锁和行锁



#### 针对于其他存储引擎(非InnoDB)

 对于`MyISAM`、`MEMORY`等存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。比方说在`Session 1`中对一个表执行`SELECT`操作，就相当于为这个表加了一个表级别的`S锁`，如果在`SELECT`操作未完成时，`Session 2`中对这个表执行`UPDATE`操作，相当于要获取表的`X锁`，此操作会被阻塞，直到`Session 1`中的`SELECT`操作完成，释放掉表级别的`S锁`后，`Session 2`中对这个表执行`UPDATE`操作才能继续获取`X锁`，然后执行具体的更新语句。 



#### InnoDB中的表级锁

InnoDB是同时支持表锁和行锁的。

InnoDB一般不会在操作的时候(如`SELECT`,`INSERT`,`UPDATE`,`DELETE`)对表加`S锁`或`X锁`的。但是可以手动获取InnoDB提供的表级别的`S锁`，`X锁`:

```sql
LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。
LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。
```

在对使用`InnoDB`存储引擎的表的某些记录加`S锁`之前，那就需要先在表级别加一个`IS锁`

在对使用`InnoDB`存储引擎的表的某些记录加`X锁`之前，那就需要先在表级别加一个`IX锁`。 

#### InnoDB中的行锁

假如有表，并且数据如下:

```
mysql> SELECT * FROM hero;
+--------+------------+---------+
| number | name       | country |
+--------+------------+---------+
|      1 | l刘备      | 蜀      |
|      3 | z诸葛亮    | 蜀      |
|      8 | c曹操      | 魏      |
|     15 | x荀彧      | 魏      |
|     20 | s孙权      | 吴      |
+--------+------------+---------+
```

那么该`hero`表的聚簇索引应该是如下:

![](/images/mysql/cluster-index-hero.png)



InnoDB的行锁有几种类型，不同类型的行锁效果不一样。

##### Record Locks（记录锁）

就是通常意义上的的针对于记录的锁，官方文档上称为`LOCK_REC_NOT_GAP`。对于这种类型的锁，就跟之前介绍的`X锁`、`S锁`一样。当一个事务获取了一条记录的`S锁`后，其他事务也可以继续获取该记录的`S锁`，但不可以继续获取`X锁`；当一个事务获取了一条记录的`X锁`后，其他事务既不可以继续获取该记录的`S锁`，也不可以继续获取`X锁`

##### Gap Locks(间隙锁)

`MySQL`在`REPEATABLE READ`（RR）隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用`MVCC`方案解决，也可以采用`加锁`方案解决。但是在使用`加锁`方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上`记录锁`。`InnoDB`提出了一种称之为`Gap Locks`的锁，官方的类型名称为：`LOCK_GAP`，我们也可以简称为`gap锁`(间隙锁)。比方说我们把`number`值为`8`的那条记录加一个`gap锁`的示意图如下：

![](/images/mysql/gap-lock.png)

如图中为`number`值为`8`的记录加了`gap锁`，意味着不允许别的事务在`number`值为`8`的记录前边的`间隙`插入新记录，其实就是`number`列的值`(3, 8)`这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条`number`值为`4`的新记录，它定位到该条新记录的下一条记录的`number`值为8，而这条记录上又有一个`gap锁`，所以就会阻塞插入操作，直到拥有这个`gap锁`的事务提交了之后，`number`列的值在区间`(3, 8)`中的新记录才可以被插入。

`gap锁`仅仅是为了防止插入幻影记录而提出的。



##### Next-Key-Locks

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的`间隙`插入新记录，`InnoDB`就提出了一种称之为`Next-Key Locks`的锁，官方的类型名称为：`LOCK_ORDINARY`，我们也可以简称为`next-key锁`。`next-key锁`的本质就是一个`记录锁`和一个`gap锁`的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的`间隙`。



##### Insert Intention Locks(插入意向锁)

我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的`gap锁`（`next-key锁`也包含`gap锁`），如果有的话，插入操作需要等待，直到拥有`gap锁`的那个事务提交。`InnoDB`规定事务在等待的时候也需要在内存中生成一个`锁结构`，表明有事务想在某个`间隙`中插入新记录，但是现在在等待。`InnoDB`把这种类型的锁命名为`Insert Intention Locks`，官方的类型名称为：`LOCK_INSERT_INTENTION`，我们也可以称为`插入意向锁`。

比方说现在`T1`为`number`值为`8`的记录加了一个`gap锁`，然后`T2`和`T3`分别想向`hero`表中插入`number`值分别为`4`、`5`的两条记录，所以现在为`number`值为`8`的记录加的锁的示意图就如下所示：

![](/images/mysql/insert-intention-lock.png)

由于`T1`持有`gap锁`，所以`T2`和`T3`需要生成一个`插入意向锁`的`锁结构`并且处于等待状态。当`T1`提交后会把它获取到的锁都释放掉，这样`T2`和`T3`就能获取到对应的`插入意向锁`了（本质上就是把插入意向锁对应锁结构的`is_waiting`属性改为`false`），`T2`和`T3`之间也并不会相互阻塞，它们可以同时获取到`number`值为8的`插入意向锁`，然后执行插入操作。事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。





### 参考资料

- [掘金小册-MySQL是怎么运行的](https://juejin.im/book/5bffcbc9f265da614b11b731/section/5c42cf94e51d45524861122d)
- [mysql锁详解](http://www.cnblogs.com/luyucheng/p/6297752.html)
- [mysql优化笔记](http://www.jianshu.com/p/163c96983ca9)
- [mysql数据库锁定机制](http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html)
- [美团点评-Innodb中事务隔离级别和锁的关系]( https://tech.meituan.com/2014/08/20/innodb-lock.html )