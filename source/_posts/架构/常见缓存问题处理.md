---
title: 常见缓存问题处理
date: 2019-11-04 17:58:19
tags:
categories: 架构
---

### 概述

在使用缓存的过程中，考虑到缓存系统的高并发和高可用， 我们绕不过三个问题缓存雪崩、缓存穿透、缓存击穿。

这里对这几个情况的处理办法做一个总结


### 缓存雪崩

很多使用场景，查询的缓存数据都是由定时任务取刷新，然后缓存查不到从 DB 查了在更新缓存。如果这些 key 在同一时间失效， 那么失效的时候， 大量的请求过来。就会直接打到 DB　上，　这个时候　DB　很可能被打垮，　即使马上重启也会被新的流量打垮。

这种同一时间大量缓存的失效，导致请求直接打到　DB 上的情况， 就是缓存雪崩。

针对于这种情况，在批量写 Redis 数据的时候， 可以给 key 的失效时间增加一个随机值， 保证他们不会在同一时间大面积失效。或者是设置数据永不过期，如果有数据有更新再更新缓存。

Redis 设置 key 的随机过期时间:
```java
setRedis（Key，value，time + Math.random() * 10000）；
```

### 缓存穿透

缓存穿透指的是缓存缓存和数据库中都没有的数据，而用户不断发起请求，让请求直接落再DB上，增加数据库压力，可能导致数据库被击垮。这种请求很可能是攻击者恶意发起的。

针对这种情况首先要做好数据校验，不合法的数据尽量拦截掉，其次如果缓存差不到，数据库也查不到的数据也缓存起来。将 value 存个null， 过期时间短一点(如30s，如果设置太长肯恶搞导致正常的情况数据没法及时更新)。 

另外还可以使用 Redis 提供的布隆过滤器，可以高效的判断出某个key是否在数据库当中，如果通过布隆过滤器判断出不存在，直接返回，存在了在去DB取数据刷新缓存。

### 缓存击穿

缓存击穿类似于缓存雪崩，不同的是缓存击穿是某个非常热点的 Key 扛着大量的并发，在这个 Key 失效的瞬间大量的请求就到了DB。这种情况需要更新缓存的时候加上互斥锁，代码如下：
```java
public List<String> getData04() throws InterruptedException {
    List<String> result = new ArrayList<String>();
    result = getDataFromCache();
    if (result.isEmpty()) {
        // 这里如果是多个实例的应用，可以用分布式锁
        if (reenLock.tryLock()) {
            try {
                System.out.println("我拿到锁了,从DB获取数据库后写入缓存");
                result = getDataFromDB();
                setDataToCache(result);
            } finally {
                reenLock.unlock();// 释放锁
            }
        } else {
            result = getDataFromCache();// 先查一下缓存
            if (result.isEmpty()) {
                System.out.println("我没拿到锁,缓存也没数据,先小憩一下");
                Thread.sleep(100);// 小憩一会儿
                return getData04();// 重试
            }
        }
    }
    return result;
}
```


