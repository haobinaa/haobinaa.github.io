---
title: 秒杀系统设计
date: 2019-06-06 11:33:57
tags:
categories: 架构
---

### 概述

读了极客时间许令波的如何设计秒杀系统后，总结出秒杀系统设计的一些需要注意的点，如何从更多的角度去考量一个架构的设计，保证性能和高可用。

这些经验或者说原则不仅仅适用于秒杀系统，在设计其他系统的时候也有一定的参考性。


### 秒杀系统的五个原则

总结起来就是：4要，1不要

#### 数据要尽量少

这里的数据值得是用户和系统间传输的数据，包括用户上传给系统的数据和系统返回给用户的数据。

数据少涉及几个方面：
1. 数据在网络中传输需要时间，数据量越大，网络包耗时越长
2. 服务器在写网络的时候，一般要进行压缩和字符编码，这些操作比较消耗cpu
3. 系统依赖的数据要尽量少， 比如和数据库的交互，很容易形成瓶颈

#### 请求数要尽量少

当用户请求页面后，还会有一些其他的额外请求，如静态资源css/js等，每一个请求都会做三次握手，如果资源不在同一个域名下，还会对dns解析形成负担。

可以将多个资源合成一个文件，尽可能对减少请求数

#### 路径要尽量短

路径指的是，用户发出一个请求到返回数据的过程中，经过的中间节点数。

每新增一个节点不但会新增一次网络连接，并且会新增不确定性(多一个节点，就会增加多一个风险点)。缩短请求路径可以增加可用性，也能提升性能。做法一般是将多个互相依赖多应用合并部署在一起，将RPC调用变为本地JVM调用


#### 依赖要尽量少

依赖指的是完成一次用户请求必须依赖的系统或者服务。分为强依赖(必须的依赖)和弱依赖(必要时可以去掉)

如秒杀页面必须依赖商品信息、用户信息，但是其他如优惠券、成交列表等并不是非要不可的信息，这些弱依赖就可以在紧急的时候去掉。

做法一般是将系统按重要程度进行分级，0级系统要尽量减少对1级系统的依赖，防止重要系统被不重要系统拖垮，在极端情况下可以把不重要系统降级，防止拖垮重要系统。

#### 不要有单点

在系统设计中，保证高可用，我们会将每个应用部署多份，作为备份，这也是分布式系统最重要的一点。

避免单点的关键是不要将服务的状态与机器绑定，即将服务无状态化，这样服务就可以在机器中随意移动。将服务与机器状态解耦的方式：与机器相关的配置动态化，服务启动的时候从配置中心拉取，在配置中心设置一些规则来改变这些映射关系。

### 秒杀系统架构

![](/images/arch/miaosha.jpg)

1. 秒杀系统单独打造一个系统，与普通的商品购买独立出来，可以单独的作优化
2. 秒杀系统部署在独立机器集群，秒杀的大流量不会影响到正常的商品购买集群的负载
3. 热点数据(如库存数据)单独放到缓存系统中，提升读性能
4. 增加秒杀答题，防止有秒杀器抢单
5. 页面进行动静分离，让用户秒杀使不在刷新整个界面(又重新加载所有资源),将页面刷新的数据降到最少
6. 服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压跨公共缓存集群

#### 动静分离

为了提升系统的速度，需要从两个方面去考虑：
1. 提高单次请求的效率
2. 减少不必要的请求

动静分离就是针对这个大方向去考量的，尽量只刷新局部数据，分离动态数据和静态数据，每次只请求动态数据，将静态数据缓存起来，客户端大幅度减少了请求的数据量。


##### 缓存静态数据

1. 针对不会变的静态数据，应缓存到离用户最近的地方。常见的：用户浏览器中，CDN或服务端的Cache中。

2. 静态改造。相较于普通的数据缓存，静态化改造直接缓存HTTP连接而不是仅仅缓存数据，web服务器根据请求的URL直接取出对应的HTTP响应头和响应体直接返回，不用解析HTTP头也不同重装HTTP协议。与HTTP缓存相关的字段：
- Pragma+Expires/Cache-Control(强制缓存)：program为nocache时，客户端不会读取缓存，每次都会向服务端发请求。Expires来定义缓存的失效时间。但是expires是服务端时间，针对服务端时间与客户端不统一的情况，http1.1使用cache-control来定义缓存过期时间。优先级：Pragma>Expires>Cache-Control

- Last-Modified/Etag(对比缓存):服务器将资源最后更改时间以Last-modified返回给客户端，客户端请求端时候将这个时间一并传给服务端做检查，如果资源没有被修改过，直接返回304，内容为空。Last-modified无法处理一秒内文件多次修改端情况，http1.1使用ETag字段，通过某种算法给资源计算出唯一标志符，客户端请求时将这个标志一起传给服务端，通过对比判断资源是否已经被修改。

3. 在哪一层做静态缓存也很重要,不同语言的缓存处理数据的效率也不同。Java不擅长处理大量连接  请求(每个连接消耗的资源多，servelet容器解析http协议慢)，所以不必在Java层做静态缓存，相比Java，Web服务器(Nginx,Apache)更擅长处理大量并发静态请求。

##### 如何做静态化改造

分离出动态数据，以商品详情页为例子:
1. URL唯一化: 如果要缓存整个http连接，需要以唯一的http url作为key
2. 分离浏览者相关的因素。浏览者相关的因素包括是否登陆以及登陆身份等，这些信息可以通过动态请求获取
3. 分离时间因素，服务器时间也通过动态请求获取(以防客户端时间和服务端时间不一致)
4. 去掉Cookie。缓存等静态数据中不含有cookie

通过上述的原则可以分离出动态数据，这样静态数据可以通过缓存来处理，动态数据的处理通常有两种方案：
1. ESI：在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面的时候，已经是一个完整的页面离，这种方式对服务端性能有些影响
2. CSI: 单独发起异步的JavaScript请求，向服务端获取动态内容。这种方式服务端性能更好，但用户端页面可能会延时，体验稍差


#### 热点数据处理


### 参考资料
- [http缓存控制](https://imweb.io/topic/5795dcb6fb312541492eda8c)