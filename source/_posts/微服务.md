---
title: 微服务
date: 2018-02-04 15:01:38
tags: 微服务
categories: 架构
---

### 架构的演变

#### 单体式架构

没有模块的划分，用一个项目就涵盖了所有逻辑，也是我们最开始写的程序，易于测试和部署发布。

单体应用非常简单，但这也是他致命的缺点，随着业务的不断增加，复杂度越来越高，项目中的代码越来越不可控，就造成了很多问题：

1. 代码量过多，结构过于复杂
2. 可靠性低下：所有代码都运行在同一进程中，模块中任何一个bug，比如内存泄露都可能弄垮整个进程
3. 技术更新困难： 技术选型在一开始就定下来了
4. 启动时间过长： 我们知道代码量越多，应用的启动时间就会随之变长。当应用程序规模超大的，启动时间成了巨大的问题
5. 难以持续部署： 现在， SaaS 应用的发展水平足以在单日内多次将修改推送到生产环境。然而要让复杂的单个应用达到此水平却极为棘手。想更新应用的单个部分，必须重新部署整个应用，漫长的启动时间更是雪上加霜。另外，由于不能完全预见修改的影响，你不得不提前进行大量人工测试。结果就是，持续部署变得不可能
6. 扩展变得艰难

#### SOA

SOA是一种架构的设计方法，是包含运行环境、编程模型、架构风格和相关方法论等在内的一整套新的分布式软件系统构造方法和环境，涵盖服务的整个生命周期：建模-开发-整合-部署-运行-管理

在SOA架构风格中，服务是最核心的抽象手段，业务被划分（组件化）为一系列粗粒度的业务服务和业务流程。业务服务相对独立、自包含、可重用，由一个或者多个分布的系统所实现，而业务流程由服务组装而来

SOA 并不代表一个特定的技术或者是特定的方案，它只是为设计人员提供指导。而现在最为人所知的 SOA 架构的风格的则是 ESB（即企业服务总线）



### 微服务架构

微服务就是用来解决之前架构上的问题而演化出来的

#### 微服务的特点

- 一组小的服务：微服务将业务拆出来，拆成一个个小的独立的服务
- 独立的进程： 每个微服务都部署在独立的容器中，以进程的方式横向扩展微服务
- 轻量级的通信协议： 如http，短小格式的通信格式
- 基于业务能力
- 独立部署： 每个服务的开发、迭代都可以独立部署，每个团队维护自己的服务
- 没有集中式的管理： 每个服务可以采用不同的技术栈

#### 微服务的利弊

微服务的优势：

1. 强模块化边界：更加模块化，边界很清晰
2. 可独立部署
3. 技术多样性


微服务的缺陷：

1. 分布式复杂性
2. 最终一致性，如不同服务之间数据的一致性，相互关联的服务数据如何保持一致
3. 运维复杂性
4. 测试的复杂性： 集成测试就需要各个团队合作测试，复杂性增加

#### 微服务的特性

##### 1.组件化

微服务中有两种组件：服务(Service)和库(Library)，微服务选取服务作为一个独立的组件，一个组件即一个服务

- 服务(Service):是一种通过轻量级通信机制（如 HTTP 请求等）来进行通信的进程外组件。可独立部署，并且接口更明确
- 库(Library):是一种链接到项目里，并通过内存中的函数调用方式进行调用的组件。虽然通信成本低，但是一旦更改了一个库，整个应用就必须要重新部署


##### 2.团队组织

一个小型的团队更有助于一个服务的开发，因为小规模的团队成员之间的沟通成本小，更能专注于业务本身。所以将一个大的应用分割成每一个规模不大、独立的服务

##### 3.通讯机制
微服务架构中的通信机制是以 明确的接口 和 轻量级通信机制 为基础的。因为现在网络的通常我们会选择 REST 风格的 HTTP 请求

##### 4.组件分治

因为各个组件由各个专属团队负责，而且采用通用的HTTP请求来进行通信，所以各组件之间所采用的技术就毫无关系了，可以使用不同的框架、不同的编程语言、甚至不同的存储方式（关系型数据库或者是NOSQL等），只要满足协议规定的接口即可。这就极大的提高了技术和管理自由度。

##### 5.数据管理分治

对于数据存储的管理，这里推荐的是各个服务管理其自有数据库，即去中心化管理数据。因为我们在使用领域模型驱动分解系统的时候，已经明确的界定了上下文边界，也就将数据模型划分到了各个组件之中

##### 6.容错设计

由于微服务的架构服务独立部署、独立运维的特征，各个服务随时出现故障，或者服务间在调用的过程中很容易出现错误或调用失败，导致相应的功能流程出现问题或者数据纰漏。所以容错设计就非常的重要了。

为此我们需要监控到微服务架构中的元素和业务先关的指标，比如各种状态和操作的情况、业务相关的指标、当前系统的吞吐量和延迟情况等。

##### 7.基础设计自动化

基础设施自动化技术在过去几年中得到了长足的发展：云计算，特别是AWS的发展，减少了构建、发布、运维微服务的复杂性。

微服务架构中的每一个服务所依赖的基础设施自动化和之前的单体式应用并无不同，只是更加依赖，尤其是更多的自动化测试，以保证各个服务的可靠性。


### 微服务设计

![](/images/microservice.png)

#### API网关

我们将微服务划分成了几个隔离的服务，服务之间基于轻量级的通信机制来进行数据交换， 但是这对客户端来说，如果同时需要A、B两个服务的数据，就需要知道A、B两个服务的地址，如果更新了服务的地址，同样就要更新客户端的地址

显然我们需要一种解决方案，让客户端和服务端解耦， 引入一个中间件把客户端发来的消息转发给指定后台，承担起微服务入口的功能，我们称之为API网关。



![](/images/API-Gateway.png.jpg)


API网关的主要功能：
- 负载均衡： 反向路由，将外部请求转换为内部访问
- 安全认证： 将恶意的访问档在网关之外
- 限流熔断： 如果有突发流量，进行限流熔断(服务降级：降低非主流业务功能减轻系统压力； 熔断：当流量过大，启动熔断机制，拒绝服务或者引流，避免系统瘫痪)
- 日志监控： 保存日志和分析日志




#### 服务发现

1.传统LB模式

DNS -> LB(load balance) -> service provider

域名通过DNS解析，通过负载均衡器找到后台的服务

2.进程内LB模式

service provider ->(register)  service registry -> customer(内置LB) -> service provider

后台服务在服务注册表中注册，客户端有个内置的LB，指向对应的服务提供方


3.主机独立LB模式

service provider ->(register)   service registry  -> 
customer(在同一个主机中，LB存在于一个独立的进程中) -> service provider

相比于第二种，单独的LB跟客户端关联没那么紧密，不需要为每种语言都配置一个LB 


#### 数据存储

在传统单体式项目中，一个应用中的各个模块共用一个数据库，它能很好地保证事务一致性。而在微服务架构中，如果共用一个数据库则会有高耦合度的问题，比如一个服务想要修改一个表的结构，那么它在修改的时候要极其小心，应该这个表也可能是其他服务正在使用的，所以我们让每个服务管理对应的数据库。

在分解数据库的时候，有很多问题：事务一致性、外键关系、静态数据处理、共享数据和共享表的处理等等。

build microservice提供的解决方案：
- 外键关系：把这个约束转移至代码中，在需要的时候通过 API 去其他服务请求数据
- 静态数据：
    - 方法1：每个服务复制一份该表的内容
    - 方法2：将这些共享的静态数据放入静态配置文件或代码之中；（推荐）
    - 方法3： 将这些静态数据放入一个单独的服务，如果数据量和相关的规则复杂就可以使用这个方法
- 共享数据：我们可以将共享的部分提取出来，新建一个服务管理这些数据，其他服务访问这个新服务来获取数据
- 共享表：把表按照需求拆分

