---
title: GC算法和垃圾收集器
date: 2018-11-11 18:06:07
tags:
categories: jvm
---
### 判断对象是否存活

垃圾收集器在对堆回收之前，第一件事情就是要确定这些对象哪些还“存活”着，哪些对象已经“死去”(即不可能再被任何途径使用的对象)、

#### 引用计数算法(Reference Counting)

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互循环引用的问题。

例如：在testGC()方法中，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外这两个对象再无任何引用，实际上这两个对象都已经不能再被访问，但是它们因为相互引用着对象方，异常它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
``` 
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        //假设在这行发生了GC，objA和ojbB是否被回收
        System.gc();
    }
}
```

#### 可达性分析算法(GC Roots Analysis)

主流的判断算法，这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会标记为是可回收对象。

![](/images/GCRootReachAnalysis.png)

在Java语言里，可作为GC Roots对象的包括如下几种：
1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象(static 属性)
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI的引用的对象

#### finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历**再次标记**过程。

真正的判断一个对象死亡，至少要经过俩次标记过程：如果对象在进行根搜索后发现没有与GC roots相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法，当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。

两次标记过程：

##### 1)第一次标记并进行一次筛选。

筛选的条件是此对象是否有必要执行finalize()方法。

当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。

##### 2) 第二次标记

如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F
-Queue
队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

整个流程如下：

![](/images/finalized.png)


### GC回收动作
针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：

- Partial GC：并不收集整个GC堆的模式:
  - Young GC：只收集young gen的GC, 也叫Minor GC
  - Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
  - Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式
- Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。


#### Yonug GC

Young GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。


当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Young GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。


Young GC触发条件： 一般是新生代中Eden区满时，Young GC

![](/images/jvm/young-gc.png)

#### Major GC / Full GC

Full GC 就是收集整个堆，包括新生代，老年代，永久代(在JDK 1.8及以后，永久代会被移除，换为metaspace)等收集所有部分的模式

针对不同的垃圾收集器，Full GC的触发条件可能不都一样


最简单的分代式GC策略，按HotSpot VM的serial GC（serial+serial old）的实现来看，触发条件是：young GC：当young gen中的eden区分配满的时候触发。注意young 
GC中有部分存活对象会晋升到old 
gen，所以young GC后old gen的占用量通常会有所升高。full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。


### GC算法

#### 标记-清除算法 (Mark-Sweep)

标记-清除算法将垃圾回收分为两个阶段：
1. 标记阶段：首先标记出所有需要回收的对象。(如对象存活所示)
2. 清除阶段：标记完成后，统一回收被标记的对象


##### 缺点
1. 效率问题：标记清除过程效率都不高
2. 空间问题：标记清除之后会产生大量的不连续的内存碎片(空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作）

#### 复制算法 (Copying)

复制算法过程：
1. 将现有的内存空间分为两快，每次只使用其中一块.
2. 当其中一块时候完的时候，就将还存活的对象复制到另外一块上去
3. 再把已使用过的内存空间一次清理掉

##### 优点
1. 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。
2. 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

##### 缺点
1. 内存减少为原来的一半，太浪费了
2. 对象存活率较高的时候就要执行较多的复制操作，效率变低


##### 算法的演进(java Heap 内存回收模型)

并不需要根据1:1划分内存空间，而是将内存划分为一块较大的EdenSpace和两块较小的SurvivorSpace

备注： 目前jvm使用此算法回收新生代

如图：

![](/images/gc-copying.png)

#### 标记-整理算法 (Mark-Compact)

由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。

标记-压缩过程：
1. 标记阶段：首先标记出所有需要回收的对象。
2. 让存活的对象向内存的一端移动。而不跟“mark-sweep”直接对可回收对象进行清理
3. 再清理掉边界以外的内存。

过程如图：
![](/images/mark-compact.png)

由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记-清理算法或者标记整理算法。

#### 分代收集算法 (Generational Collecting)

把Java堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法

在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-压缩”算法来进行回收。

### 垃圾收集器
如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

gc收集器的各个年代分布,`?`代表g1收集器， 连线代表可以搭配使用：

![](/images/gc-generation.jpg)

#### Serial收集器

默认的新生代收集器

##### 特点
1. 单线程的收集器，说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作
2. 在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”）,直到它收集结束。这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial
收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。

缺点： GC时暂停线程带给用户不良体验


#### ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样。同样适用于新生代

ParNew是除了Serial之外唯一能与CMS配合工作的，但是由于多线程的交互开销，在单CPU的情况下，效果并不比serial好

##### 特点
1. 多线程GC(并行):ParNew是Serial的多线程版本，两者共用了许多代码
2. 在GC时暂停所有用户线程

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：高效

缺点：GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial

#### Parallel Scavenge收集器

使用于新生代， Parallel Scavenge主要在于精确的控制吞吐量， 适合后台运算、交互不多的任务(CMS等则是尽可能的缩短垃圾收集时用户线程停顿的时间， 用于交互任务)

##### 特点
1. 多线程GC(并行)
2. 在GC时暂停所有用户线程

与其他收集器不同的是：

1）ParNew,CMS等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间；而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。[备注：吞吐量：运行代码时间/（运行用户代码时间+垃圾收集时间）]

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

2）Parallel Scavenge可采用GC自适应的调节策略。
使用自适应的调节策略： 即不需要指定新生代的大小，Eden与Surivior的比例，晋升老年代的年龄等细节参数，虚拟机自动根据根据当前系统的状态动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量。

参数：用于精确控制吞吐量
- -XX:MaxGCPauseMillis 最大垃圾收集停顿时间
- -XX:GCTimeRatio 垃圾收集时间与运行用户代码时间的比例=垃圾收集时间/运行用户代码时间,相当于是吞吐量的倒数。
- -XX:+UseAdaptiveSizePolicy GC自适应的调节策略。


采用收集算法：复制算法(copying)

搭配：Parallel Old或Serial Old(MSC) 

#### Serial Old(MSC)收集器

适用
　　1).运行在Client模式下的虚拟机中的老年代
　　2).在Server模式下，它主要还有两大用途
　　①.与Parallel Scavenge搭配
　　②.作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用

特点: 1.单线程GC，Serial收集器的老年代版本
　　  2.在GC时暂停所有用户线程

算法：采用标记-整理算法

优点：简单，高效

缺点：GC时暂停线程带给用户不良体验

搭配：Serial Old(MSC)或ParNew

#### Parallel Old收集器

Parallel Scavenge的老年代版本，适用于注重吞吐量和CPU资源敏感的场合

特点
　　1).多线程GC(并行):Parallel Scavenge的老年代版本
　　2).在GC时暂停所有用户线程

算法：采用标记-整理算法

优点：高效

搭配：Parallel Scavenge（这个组合适用于一些长期运行且对吞吐量要求较高的后台程序）

#### CMS(Concurrent Mark Sweep)收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S
系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

适用：运行在Server模式下的虚拟机中的老年代，适合对响应时间要求高的应用。

算法：采用“mark sweep”算法

特点: 多线程 并发(gc线程与用户线程交替执行)

##### 实现过程
1. 初始标记：标记GC Roots能直接关联的对象,速度很快
2. 并发标记：进行GC Roots Tracing的过程
3. 重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
4. 并发清除：用户线程与清除线程并发。

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。

优点:并发收集、低停顿–由于耗时最长的并发标记和并发清除阶段都与用户线程并行工作，故系统停顿时间极短。

缺点：

1). 对CPU资源非常敏感。
原因：面向并发设计的程序都对CPU资源比较敏感。并发时，因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当CPU数不足时，尤其明显。
解决：增量式并发收集器（i-CMS）：在并发标记、清除时让GC线程与用户线程交替运行，以降低GC线程独占CPU的时间。但GC时间将变长时，效果一般，被丢弃使用。

2).无法处理浮动垃圾,可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
浮动垃圾：在并发清除阶段，用户线程仍在运行，这段时间用户线程产生的新的垃圾， 这部分CMS无法在当次收集。

也是因为并发清除阶段用户线程还需要运行，所以无法等老年代几乎填满了才运行， 需要预留一部分空间给用户线程在清除阶段使用， 可以通过`-XX:CMSInitiatingOccupancyFration`来设置触发百分比， 
如果CMS期间预留内存不足，则会出现`concurrent mode fai lure`， 此时虚拟机启动预备方案，临时启用Serial Old进行回收(full gc)。

3).产生空间碎片，影响大对象的分配。
这是由于该收集器是由“标记-清楚”算法实现的所引起的。所以往往存在有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前出发一次Full GC。

解决：
1. -XX:+UseCMSCompactFullCollection 开关参数（默认开启）用于当CMS要进行Full GC时开启内存碎片的合并整理过程,该过程不能并发，故停顿时间变长。
2. -XX:CMSFullGCsBeforeCompaction 用于设置执行多少次不压缩的Full GC后跟着来一次带压缩的Full GC。默认为0，表示每次进入Full GC时都进行碎片整理。

搭配：Serial或ParNew


##### 常见问题

1. 最终标记阶段停顿时间过长

CMS 的 GC 停顿时间约 80% 都在最终标记阶段（Final Remark），若该阶段停顿时间过长，常见原因是新生代对老年代的无效引用，在上一阶段的并发可取消预清理阶段中，执行阈值时间内未完成循环，来不及触发 Young GC，清理这些无效引用。
通过添加参数：`-XX:+CMSScavengeBeforeRemark`
在执行最终操作之前先触发 Young GC，从而减少新生代对老年代的无效引用，降低最终标记阶段的停顿。
但如果在上个阶段（并发可取消的预清理）已触发 Young GC，也会重复触发 Young GC


2.  并发模式失败 & 晋升失败

- 并发模式失败：当 CMS 在执行回收时，新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升的对象时，CMS 垃圾回收就会退化成单线程的 Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收

- 晋升失败：当新生代发生垃圾回收，老年代有足够的空间可以容纳晋升的对象，但是由于空闲空间的碎片化，导致晋升失败，此时会触发单线程且带压缩动作的 Full GC


#### G1收集器
  
G1 的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量。G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。

如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。
  
##### G1概述
  
G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。

![](/images/jvm/g1.png)

执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程并发执行，标记结束后，G1 也就知道哪些区块基本上是垃圾（存活对象极少），G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间.

在 G1 中，目标停顿时间非常非常重要，用 `-XX:MaxGCPauseMillis=200` 指定期望的停顿时间。

G1 使用了停顿预测模型来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。

#### G1工作流程
G1 收集器主要包括了以下 4 种操作：
1. 年轻代收集
2. 并发收集
3. 混合式垃圾收集
4. 必要时的 Full GC(应极力避免)

##### 年轻代收集

![](/images/jvm/g1-heap.png)

年轻代中的垃圾收集流程（Young GC）：
![](/images/jvm/g1-young-gc.png)

可以看到年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。

##### Old GC / 并发标记周期

把 Old GC 理解为并发周期是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。流程如下:
1. 初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。
2. 扫描根引用区：扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束(这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC)。
3. 并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断(这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程)
4. 重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法(这个阶段会回收完全空闲的区块)。
5. 清理：清理阶段真正回收的内存很少

到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的

##### 混合垃圾回收周期

并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。

混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。

##### Full GC

以下几种会导致 Full GC 的情况，是我们需要极力避免的：

1.concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。这个时候说明了:
- 堆需要增加了
- 或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束
- 或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期


2.晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。
>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块

3.疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的(这个时候最简单的就是增加堆的大小)

4.大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象

##### G1参数配置

G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间，有以下几点我们可以进行调整的方向：
- 增加堆大小，或调整老年代和年轻代的比例
- 增加并发周期的线程数量，其实就是为了加快并发周期快点结束
- 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）
- 在混合垃圾回收周期中回收更多的老年代区块


常用的参数:
- -XX:+UseG1GC(使用G1收集器)

- -XX:MaxGCPauseMillis=200(指定目标停顿时间，默认值 200 毫秒)

- -XX:InitiatingHeapOccupancyPercent=45(整堆使用达到这个比例后，触发并发 GC 周期，默认 45%)
> 可以通过调整这个数值，使并发周期提前进行, 降低晋升失败

- -XX:NewRatio=n(老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代)

- -XX:SurvivorRatio=n(Eden/Survivor，默认值 8，这个和其他分代收集器是一样的)

- -XX:MaxTenuringThreshold =n(从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的)

- -XX:ParallelGCThreads=n(并行收集时候的垃圾收集线程数)

- -XX:ConcGCThreads=n(并发标记阶段的垃圾收集线程数)
>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：
ConcGCThreads=(ParallelGCThreads + 2) / 4^3

- -XX:G1HeapRegionSize=n

每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。

### GC日志

#### young gc

![](/images/jvm/young-gc-log.png)

#### full gc
![](/images/jvm/full-gc-log.png)

#### 文字说明
每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：

```
33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]  
100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]

```

最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

　　GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。
　　例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。
　　[Full GC 283.736: [ParNew: 261599K->261599K(261952K), 0.0000288 secs]
　　接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

　　后面方括号内部的“3324K->152K(3712K)”含义是“GC前该内存区域已使用容量-> GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K->152K(11904K)”表示“GC前Java堆已使用容量 -> GC后Java堆已使用容量 (Java堆总容量)”。

　　再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

### 内存分配规则

对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB
上分配。少数情况下也可能会直接分配在老年代中。  

有以下几条普遍的内存分配规则

#### 对象优先分配在Eden区域
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

#### 大对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组（byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

#### 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。

#### 动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。


### 参考资料
- [周志明-深入理解JVM虚拟机]
- [Minor GC、Major GC和Full GC之间的区别](https://segmentfault.com/a/1190000007723051)
- [jvm垃圾收集器和内存分配策略](http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)
- [cms收集器为何没有采用Mark-Sweep](http://hllvm.group.iteye.com/group/topic/38223)
- [full gc 和 minor gc](https://juejin.im/post/5b8d2a5551882542ba1ddcf8)
- [gc原理和性能调优实践](https://juejin.im/post/5d8c5a5de51d4578323d51bd)