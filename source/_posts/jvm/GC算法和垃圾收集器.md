---
title: GC算法和垃圾收集器
date: 2018-11-11 18:06:07
tags:
categories: jvm
---
### 判断对象是否存活

垃圾收集器在对堆回收之前，第一件事情就是要确定这些对象哪些还“存活”着，哪些对象已经“死去”(即不可能再被任何途径使用的对象)、

#### 引用计数算法(Reference Counting)

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互循环引用的问题。

例如：在testGC()方法中，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外这两个对象再无任何引用，实际上这两个对象都已经不能再被访问，但是它们因为相互引用着对象方，异常它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
``` 
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        //假设在这行发生了GC，objA和ojbB是否被回收
        System.gc();
    }
}
```

#### 可达性分析算法(GC Roots Analysis)

主流的判断算法，这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会标记为是可回收对象。

![](/images/GCRootReachAnalysis.png)

在Java语言里，可作为GC Roots对象的包括如下几种：
1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI的引用的对象

#### finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历**再次标记**过程。

真正的判断一个对象死亡，至少要经过俩次标记过程：如果对象在进行根搜索后发现没有与GC roots相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法，当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。

两次标记过程：

##### 1)第一次标记并进行一次筛选。

筛选的条件是此对象是否有必要执行finalize()方法。

当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。

##### 2) 第二次标记

如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F
-Queue
队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

整个流程如下：

![](/images/finalized.png)
### GC回收动作
针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：

- Partial GC：并不收集整个GC堆的模式:
  - Young GC：只收集young gen的GC, 也叫Minor GC
  - Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式
  - Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式
- Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。


#### Minor GC
Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。


当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。


Minor GC触发条件： 一般是新生代中Eden区满时，触发Minor GC

#### Major GC / Full GC

Full GC 就是收集整个堆，包括新生代，老年代，永久代(在JDK 1.8及以后，永久代会被移除，换为metaspace)等收集所有部分的模式

针对不同的垃圾收集器，Full GC的触发条件可能不都一样


最简单的分代式GC策略，按HotSpot VM的serial GC（serial+serial old）的实现来看，触发条件是：young GC：当young gen中的eden区分配满的时候触发。注意young 
GC中有部分存活对象会晋升到old 
gen，所以young GC后old gen的占用量通常会有所升高。full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。


### GC算法

#### 标记-清除算法 (Mark-Sweep)

标记-清除算法将垃圾回收分为两个阶段：
1. 标记阶段：首先标记出所有需要回收的对象。(如对象存活所示)
2. 清除阶段：标记完成后，统一回收被标记的对象


##### 缺点
1. 效率问题：标记清除过程效率都不高
2. 空间问题：标记清除之后会产生大量的不连续的内存碎片(空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作）

#### 复制算法 (Copying)

复制算法过程：
1. 将现有的内存空间分为两快，每次只使用其中一块.
2. 当其中一块时候完的时候，就将还存活的对象复制到另外一块上去
3. 再把已使用过的内存空间一次清理掉

##### 优点
1. 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。
2. 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

##### 缺点
1. 内存减少为原来的一半，太浪费了
2. 对象存活率较高的时候就要执行较多的复制操作，效率变低


##### 算法的演进(java Heap 内存回收模型)

并不需要根据1:1划分内存空间，而是将内存划分为一块较大的EdenSpace和两块较小的SurvivorSpace

备注： 目前jvm使用此算法回收新生代

如图：

![](/images/gc-copying.png)

#### 标记-整理算法 (Mark-Compact)

由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。

标记-压缩过程：
1. 标记阶段：首先标记出所有需要回收的对象。
2. 让存活的对象向内存的一端移动。而不跟“mark-sweep”直接对可回收对象进行清理
3. 再清理掉边界以外的内存。

过程如图：
![](/images/mark-compact.png)

由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记-清理算法或者标记整理算法。

#### 分代收集算法 (Generational Collecting)

把Java堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法

在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-压缩”算法来进行回收。

### 垃圾收集器
如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

gc收集器的各个年代分布,?代表g1收集器， 连线代表可以搭配使用：

![](/images/gc-generation.jpg)

#### Serial收集器

默认的新生代收集器

##### 特点
1. 单线程的收集器，说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作
2. 在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”）,直到它收集结束。这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial
收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。

缺点： GC时暂停线程带给用户不良体验


#### ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样。同样适用于新生代

ParNew是除了Serial之外唯一能与CMS配合工作的，但是由于多线程的交互开销，在单CPU的情况下，效果并不比serial好

##### 特点
1. 多线程GC(并行):ParNew是Serial的多线程版本，两者共用了许多代码
2. 在GC时暂停所有用户线程

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：高效

缺点：GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial

#### Parallel Scavenge收集器

使用于新生代， Parallel Scavenge主要在于精确的控制吞吐量， 适合后台运算、交互不多的任务(CMS等则是尽可能的缩短垃圾收集时用户线程停顿的时间， 用于交互任务)

##### 特点
1. 多线程GC(并行)
2. 在GC时暂停所有用户线程

与其他收集器不同的是：

1）ParNew,CMS等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间；而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。[备注：吞吐量：运行代码时间/（运行用户代码时间+垃圾收集时间）]

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

2）Parallel Scavenge可采用GC自适应的调节策略。
使用自适应的调节策略： 即不需要指定新生代的大小，Eden与Surivior的比例，晋升老年代的年龄等细节参数，虚拟机自动根据根据当前系统的状态动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量。

参数：用于精确控制吞吐量
- -XX:MaxGCPauseMillis 最大垃圾收集停顿时间
- -XX:GCTimeRatio 垃圾收集时间与运行用户代码时间的比例=垃圾收集时间/运行用户代码时间,相当于是吞吐量的倒数。
- -XX:+UseAdaptiveSizePolicy GC自适应的调节策略。


采用收集算法：复制算法(copying)

搭配：Parallel Old或Serial Old(MSC) 

#### Serial Old(MSC)收集器

适用
　　1).运行在Client模式下的虚拟机中的老年代
　　2).在Server模式下，它主要还有两大用途
　　①.与Parallel Scavenge搭配
　　②.作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用

特点: 1.单线程GC，Serial收集器的老年代版本
　　  2.在GC时暂停所有用户线程

算法：采用标记-整理算法

优点：简单，高效

缺点：GC时暂停线程带给用户不良体验

搭配：Serial Old(MSC)或ParNew

#### Parallel Old收集器

Parallel Scavenge的老年代版本，适用于注重吞吐量和CPU资源敏感的场合

特点
　　1).多线程GC(并行):Parallel Scavenge的老年代版本
　　2).在GC时暂停所有用户线程

算法：采用标记-整理算法

优点：高效

搭配：Parallel Scavenge（这个组合适用于一些长期运行且对吞吐量要求较高的后台程序）

#### CMS(Concurrent Mark Sweep)收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S
系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

适用：运行在Server模式下的虚拟机中的老年代，适合对响应时间要求高的应用。

算法：采用“mark sweep”算法

特点: 多线程 并发(gc线程与用户线程交替执行)

##### 实现过程
1. 初始标记：标记GC Roots能直接关联的对象,速度很快
2. 并发标记：进行GC Roots Tracing的过程
3. 重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
4. 并发清除：用户线程与清除线程并发。

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。

优点:并发收集、低停顿–由于耗时最长的并发标记和并发清除阶段都与用户线程并行工作，故系统停顿时间极短。

缺点：

1). 对CPU资源非常敏感。
原因：面向并发设计的程序都对CPU资源比较敏感。并发时，因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当CPU数不足时，尤其明显。
解决：增量式并发收集器（i-CMS）：在并发标记、清除时让GC线程与用户线程交替运行，以降低GC线程独占CPU的时间。但GC时间将变长时，效果一般，被丢弃使用。

2).无法处理浮动垃圾,可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
浮动垃圾：在并发清除阶段，用户线程仍在运行，这段时间用户线程产生的新的垃圾， 这部分CMS无法在当次收集。

也是因为并发清除阶段用户线程还需要运行，所以无法等老年代几乎填满了才运行， 需要预留一部分空间给用户线程在清除阶段使用， 可以通过`-XX:CMSInitiatingOccupancyFration`来设置触发百分比， 
如果CMS期间预留内存不足，则会出现`concurrent mode fai lure`， 此时虚拟机启动预备方案，临时启用Serial Old进行回收(full gc)。

3).产生空间碎片，影响大对象的分配。
这是由于该收集器是由“标记-清楚”算法实现的所引起的。所以往往存在有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前出发一次Full GC。

解决：
1. -XX:+UseCMSCompactFullCollection 开关参数（默认开启）用于当CMS要进行Full GC时开启内存碎片的合并整理过程,该过程不能并发，故停顿时间变长。
2. -XX:CMSFullGCsBeforeCompaction 用于设置执行多少次不压缩的Full GC后跟着来一次带压缩的Full GC。默认为0，表示每次进入Full GC时都进行碎片整理。

搭配：Serial或ParNew

#### G1收集器

面向服务端应用，适用于新生代和老年代。当前收集器技术发展的最前沿成果

特点:
　　1.并行+并发。可充分利用CPU资源, 使用cpu 多核优势来缩短'stop the world'的时间，
　　2.分代收集。可以不和其他收集器配合，以不同的方式去回收不同年代的对象
　　3.空间整合。 G1从整体看是”标记-整理“算法，从局部(两个Region之间)看，是”复制“算法。 不会产生空间碎片。
　　4.可预测的停顿。建立可预测的态度时间模型，能让使用者明确指定在一个长度为M毫秒的时间内，消耗在垃圾收集的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

当使用g1收集器的时候，java堆的内存布局就与其他收集器有很大差别，g1将整个java堆划分成多个大小相等的region，虽然还保留新生代和老年代的概念，但新生代和老年代不在物理隔离了，他们都是一部分region(不需要连续)
的集合。g1跟踪各个region里面垃圾堆的价值大小(回收所获得空间大小以及回收所需要时间)，在后台维护一个优先列表，根据允许收集时间，优先回收价值最大的region

　　难点:虽然内存分为Region，但垃圾收集不能真的以Region为单位进行，因为Region不可能是孤立的，存在某个对象被多个Region的引用，那在做可达性判断确定对象是否存活时，是否需要扫描整个堆空间呢？注意：此问题在所有的收集器中都存在（如存在新生代与老年代之间的引用）。
　　解决：1.使用Remembered Set来避免圈堆扫描。
　　过程：G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作是，会产生一个Write Barrier暂时中断操作，检查Reference类型引用的对象是否处于不同的Region（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

过程(与CMS相似)
　　1.初始标记:暂停用户线程，标记GC Roots能直接关联的对象
　　2.并发标记:用户线程与标记线程并发，进行GC Roots的Trace
　　3.最终标记修正并发标记阶段，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。
　　4.筛选回收:

　　算法： 全局标记-整理+局部复制算法
　　优点:高效，停顿时间可控、可预测

个人认为的一个缺点：相比于cms资料太少，不太容易掌握特性

### GC日志

每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：

```
33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]  
100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]

```

最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

　　GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。
　　例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。
　　[Full GC 283.736: [ParNew: 261599K->261599K(261952K), 0.0000288 secs]
　　接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

　　后面方括号内部的“3324K->152K(3712K)”含义是“GC前该内存区域已使用容量-> GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K->152K(11904K)”表示“GC前Java堆已使用容量 -> GC后Java堆已使用容量 (Java堆总容量)”。

　　再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

### 内存分配规则

对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB
上分配。少数情况下也可能会直接分配在老年代中。  

有以下几条普遍的内存分配规则

#### 对象优先分配在Eden区域
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

#### 大对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组（byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

#### 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。

#### 动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
### 参考资料
- [周志明-深入理解JVM虚拟机]
- [Minor GC、Major GC和Full GC之间的区别](https://segmentfault.com/a/1190000007723051)
- [jvm垃圾收集器和内存分配策略](http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)
- [cms收集器为何没有采用Mark-Sweep](http://hllvm.group.iteye.com/group/topic/38223)
- [full gc 和 minor gc](https://juejin.im/post/5b8d2a5551882542ba1ddcf8)