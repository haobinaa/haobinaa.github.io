---
title: GC算法和垃圾收集器
date: 2018-11-11 18:06:07
tags:
categories: jvm
---
### 判断对象是否存活

垃圾收集器在对堆回收之前，第一件事情就是要确定这些对象哪些还“存活”着，哪些对象已经“死去”(即不可能再被任何途径使用的对象)、

#### 引用计数算法(Reference Counting)

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互循环引用的问题。

例如：在testGC()方法中，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外这两个对象再无任何引用，实际上这两个对象都已经不能再被访问，但是它们因为相互引用着对象方，异常它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。
``` 
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        //假设在这行发生了GC，objA和ojbB是否被回收
        System.gc();
    }
}
```

#### 可达性分析算法(GC Roots Analysis)

主流的判断算法，这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会标记为是可回收对象。

![](/images/GCRootReachAnalysis.png)

在Java语言里，可作为GC Roots对象的包括如下几种：
1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI的引用的对象

#### finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历**再次标记**过程。

真正的判断一个对象死亡，至少要经过俩次标记过程：如果对象在进行根搜索后发现没有与GC roots相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法，当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。

两次标记过程：

##### 1)第一次标记并进行一次筛选。

筛选的条件是此对象是否有必要执行finalize()方法。

当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。

##### 2) 第二次标记

如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F
-Queue
队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

整个流程如下：

![](/images/finalized.png)
### GC回收动作

#### Minor GC
Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。


当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。


Minor GC触发条件： 一般是新生代中Eden区满时，触发Minor GC

#### Full GC
Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。

Full GC触发条件：
- 调用System.gc时，系统建议执行Full GC，但是不必然执行
- 老年代空间不足
- 方法区空间不足
- 过Minor GC后进入老年代的平均大小大于老年代的可用内存
- 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### GC算法

#### 标记-清除算法 (Mark-Sweep)

标记-清除算法将垃圾回收分为两个阶段：
1. 标记阶段：首先标记出所有需要回收的对象。(如对象存活所示)
2. 清除阶段：标记完成后，统一回收被标记的对象


##### 缺点
1. 效率问题：标记清除过程效率都不高
2. 空间问题：标记清除之后会产生大量的不连续的内存碎片(空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作）

#### 复制算法 (Copying)

复制算法过程：
1. 将现有的内存空间分为两快，每次只使用其中一块.
2. 当其中一块时候完的时候，就将还存活的对象复制到另外一块上去
3. 再把已使用过的内存空间一次清理掉

##### 优点
1. 由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。
2. 只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效

##### 缺点
1. 内存减少为原来的一半，太浪费了
2. 对象存活率较高的时候就要执行较多的复制操作，效率变低


##### 算法的演进(java Heap 内存回收模型)

并不需要根据1:1划分内存空间，而是将内存划分为一块较大的EdenSpace和两块较小的SurvivorSpace

备注： 目前jvm使用此算法回收新生代

如图：

![](/images/gc-copying.png)

#### 标记-压缩算法 (Mark-Compact)

由于复制算法的缺点，及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。

标记-压缩过程：
1. 标记阶段：首先标记出所有需要回收的对象。与“标记-清除”一样
2. 让存活的对象向内存的一段移动。而不跟“标记-清除”直接对可回收对象进行清理
3. 再清理掉边界以外的内存。

由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记-清理算法或者标记整理算法。

#### 分代收集算法 (Generational Collecting)

把Java堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法

在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-压缩”算法来进行回收。

### 垃圾收集器
如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。

#### Serial收集器

默认的新生代收集器

##### 特点
1. 单线程的收集器，说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作
2. 在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”）,直到它收集结束。这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial
收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。

缺点： GC时暂停线程带给用户不良体验


#### ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样。同样适用于新生代

##### 特点
1. 多线程GC(并行):ParNew是Serial的多线程版本，两者共用了许多代码
2. 在GC时暂停所有用户线程

采用收集算法：复制算法(copying)

搭配：CMS 或Serial Old(MSC)

优点：高效

缺点：GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial

#### Parallel Scavenge收集器

使用于新生代。在后台运行且不需要太多交互任务

##### 特点
1. 多线程GC(并行)
2. 在GC时暂停所有用户线程

与其他收集器不同的是：

1）ParNew,CMS等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间；而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。[备注：吞吐量：运行代码时间/（运行用户代码时间+垃圾收集时间）]

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

2）Parallel Scavenge可采用GC自适应的调节策略。
使用自适应的调节策略： 即不需要指定新生代的大小，Eden与Surivior的比例，晋升老年代的年龄等细节参数，虚拟机自动根据根据当前系统的状态动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量。

参数：用于精确控制吞吐量
- -XX:MaxGCPauseMillis 最大垃圾收集停顿时间
- -XX:GCTimeRatio 垃圾收集时间与运行用户代码时间的比例=垃圾收集时间/运行用户代码时间,相当于是吞吐量的倒数。
- -XX:+UseAdaptiveSizePolicy GC自适应的调节策略。


采用收集算法：复制算法

搭配：Parallel Old或Serial Old(MSC) 

#### Serial Old(MSC)收集器

适用
　　1).运行在Client模式下的虚拟机中的老年代
　　2).在Server模式下，它主要还有两大用途
　　①.与Parallel Scavenge搭配
　　②.作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用

特点: 1.单线程GC，Serial收集器的老年代版本
　　  2.在GC时暂停所有用户线程

算法：采用标记-整理算法

优点：简单，高效

缺点：GC时暂停线程带给用户不良体验

搭配：Serial Old(MSC)或ParNew

#### Parallel Old收集器

适用：运行在Server模式下的虚拟机中的新生代.在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

特点
　　1).多线程GC(并行):Parallel Scavenge的老年代版本
　　2).在GC时暂停所有用户线程
　　3).这个收集器是在JDK 1.6中才开始提供的

算法：采用标记-整理算法

优点：高效

缺点：GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial

搭配：Parallel Scavenge

#### CMS(Concurrent Mark Sweep)收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S
系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

适用：运行在Server模式下的虚拟机中的老年代，适合对响应时间要求高的应用。

算法：采用“标记-清除”算法

特点: 多线程 并发

##### 实现过程
1. 初始标记：暂停用户线程，标记GC Roots能直接关联的对象,速度很快
2. 并发标记：用户线程与标记线程并发，进行GC Roots Tracing的过程
3. 重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
4. 并发清除：用户线程与清除线程并发。

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。

优点:并发收集、低停顿–由于耗时最长的并发标记和并发清除阶段都与用户线程并行工作，故系统停顿时间极短。

缺点：

1). 对CPU资源非常敏感。
原因：面向并发设计的程序都对CPU资源比较敏感。并发时，因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当CPU数不足时，尤其明显。
解决：增量式并发收集器（i-CMS）：在并发标记、清除时让GC线程与用户线程交替运行，以降低GC线程独占CPU的时间。当GC时间将变长时，效果一般，被丢弃使用。

2).无法处理浮动垃圾,可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
浮动垃圾：在并发清除阶段，用户线程仍在运行，此时产生的垃圾无法在该次收集中处理。

3).产生空间碎片，影响大对象的分配。
这是由于该收集器是由“标记-清楚”算法实现的所引起的。所以往往存在有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前出发一次Full GC。

解决：
1. -XX:+UseCMSCompactFullCollection 开关参数（默认开启）用于当CMS要进行Full GC时开启内存碎片的合并整理过程,该过程不能并发，故停顿时间变长。
2. -XX:CMSFullGCsBeforeCompaction 用于设置执行多少次不压缩的Full GC后跟着来一次带压缩的Full GC。默认为0，表示每次进入Full GC时都进行碎片整理。

搭配：Serial或ParNew

#### G1收集器
适用：面向服务端应用，适用于新生代和老年代。当前收集器技术发展的最前沿成果

特点:
　　1.并行+并发。可充分利用CPU资源
　　2.分代收集。
　　3.空间整合。 G1从整体看是”标记-整理“算法，从局部(两个Region之间)看，是”复制“算法。 不会产生空间碎片。
　　4.可预测的停顿。建立可预测的态度时间模型，能让使用者明确指定在一个长度为M毫秒的时间内，消耗在垃圾收集的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

Garbage First名称的由来
　　G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集。G1将内存划分为Region，跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

　　难点:虽然内存分为Region，但垃圾收集不能真的以Region为单位进行，因为Region不可能是孤立的，存在某个对象被多个Region的引用，那在做可达性判断确定对象是否存活时，是否需要扫描整个堆空间呢？注意：此问题在所有的收集器中都存在（如存在新生代与老年代之间的引用）。
　　解决：1.使用Remembered Set来避免圈堆扫描。
　　过程：G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作是，会产生一个Write Barrier暂时中断操作，检查Reference类型引用的对象是否处于不同的Region（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

　　内存布局：G1的堆内存布局与其他收集器不同，G1将整个堆内存空间划分为多个大小相等的Region，虽然仍然有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，他们都是一部分Region（不需要连续）的集合。

过程(与CMS相似)
　　1.初始标记:暂停用户线程，标记GC Roots能直接关联的对象
　　2.并发标记:用户线程与标记线程并发，进行GC Roots的Trace
　　3.最终标记修正并发标记阶段，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。
　　4.筛选回收:

　　算法： 全局标记-整理+局部复制算法
　　优点:高效，停顿时间可控、可预测

### GC日志

每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：

```
33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]  
100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]

```

最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

　　GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的。
　　例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“［Full GC (System)”。
　　[Full GC 283.736: [ParNew: 261599K->261599K(261952K), 0.0000288 secs]
　　接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

　　后面方括号内部的“3324K->152K(3712K)”含义是“GC前该内存区域已使用容量-> GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K->152K(11904K)”表示“GC前Java堆已使用容量 -> GC后Java堆已使用容量 (Java堆总容量)”。

　　再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

### 参考资料
- [周志明-深入理解JVM虚拟机]
- [Minor GC、Major GC和Full GC之间的区别](https://segmentfault.com/a/1190000007723051)
- [jvm垃圾收集器和内存分配策略](http://liucw.cn/2017/12/24/jvm/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/)
- [cms收集器为何没有采用Mark-Sweep](http://hllvm.group.iteye.com/group/topic/38223)