---
title: CMS收集器和G1收集器
date: 2019-02-19 23:22:09
tags: 垃圾收集器
categories: jvm
---
### 概述

java相较于C/C++等语言的优势之一是，有着自动的内存管理和垃圾回收机制，这一机制的实现依靠于JVM提供的各种垃圾收集器，现在用的最多的应该是 CMS/G1

GC主要做的工作有：
- 分配内存, 为每个新建的对象分配空间
- 确保还在使用的对象内存一直在，不能把有用的空间当垃圾回收了
- 释放不再使用的对象所占的空间

判断哪些对象可以回收，哪些不能回收，现在用的是 GC Roots， Gc Roots 有:
- 当前各线程执行方法中的局部变量（包括形参）引用的对象
- 已被加载的类的 static 域引用的对象
- 方法区中常量引用的对象
- JNI 引用

#### 一些概念

##### 并发和并行

- 并行：多个垃圾回收线程同时工作，而不是只有一个垃圾回收线程在工作
- 并发：垃圾回收线程和应用程序线程同时工作，应用程序不需要挂起

##### 串行和并行

串行收集的情况，即使是多核 CPU，也只有一个核心参与收集。使用并行收集器的话，垃圾收集的工作将分配给多个线程在不同的 CPU 上同时进行。并行可以让收集工作更快，缺点是带来的复杂性和内存碎片问题

##### 并发 vs Stop-the-world

当 stop-the-world 垃圾收集器工作的时候，应用将完全被挂起。与之相对的，并发收集器在大部分工作中都是并发进行的，也许会有少量的 stop-the-world。

stop-the-world 垃圾收集器比并发收集器简单很多，因为应用挂起后堆空间不再发生变化，它的缺点是在某些场景下挂起的时间我们是不能接受的（如 web 应用）

相应的，并发收集器能够降低挂起时间，但是也更加复杂，因为在收集的过程中，也会有新的垃圾产生，同时，需要有额外的空间用于在垃圾收集过程中应用程序的继续使用。

##### 压缩 vs 不压缩 vs 复制

当垃圾收集器标记出内存中哪些是活的，哪些是垃圾对象后，收集器可以进行压缩，将所有活的对象移到一起，这样新的内存分配就可以在剩余的空间中进行了。经过压缩后，分配新对象的内存空间是非常简单快速的。

相对的，不压缩的收集器只会就地释放空间，不会移动存活对象。优点就是快速完成垃圾收集，缺点就是潜在的碎片问题。通常，这种情况下，分配对象空间会比较慢比较复杂，比如为新的一个大对象找到合适的空间。

还有一个选择就是复制收集器，将活的对象复制到另一块空间中，优点就是原空间被清空了，这样后续分配对象空间非常迅速，缺点就是需要进行复制操作和占用额外的空间。


#### 年代收集

在 HotSpot 虚拟机中，内存被组织成三个分代：年轻代、老年代、永久代。

大部分对象初始化的时候都是在年轻代中的。

老年代存放经过了几次年轻代垃圾收集依然还活着的对象，还有部分大对象因为比较大所以分配的时候直接在老年代分配。

>如 -XX:PretenureSizeThreshold=1024，这样大于 1k 的对象就会直接分配在老年代

永久代，通常也叫 方法区，用于存储已加载类的元数据，以及存储运行时常量池等。

##### 年轻代收集

HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过`-XX:MaxTenuringThreshold`来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

![](/images/jvm/young-gc.png)

### CMS(Concurrent Mark-Sweep)收集器

CMS是目前最常用的收集器(JDK8可能会切换成G1收集器)， 它也是一个并发的收集器， 也就是垃圾回收线程和应用程序线程同时运行。对于许多应用程序来说，吞吐量没有响应时间重要，了解决这个问题，HotSpot 虚拟机提供了 CMS 收集器，也叫做 低延时收集器。

#### CMS在年轻代中

在年轻代中，CMS 和 并行收集器 一样，即：并行、stop-the-world、复制。

#### 在老年代中使用 CMS 收集器

在老年代的垃圾收集过程中，大部分收集任务是和应用程序并发执行的。过程如下:

1. CMS 收集过程首先是一段小停顿 stop-the-world，叫做 初始标记阶段（initial mark），用于确定 GC Roots。
2. 然后是 并发标记阶段（concurrent mark），标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。
3. 为了解决上面述问题，需要再次停顿应用程序，称为 再次标记阶段（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，所以会使用多线程并行执行来增加效率。
4. 再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 并发清理阶段（concurrent sweep） 将就地回收垃圾对象所占空间

不像其他垃圾收集器，CMS 收集器不能等到老年代满了才开始收集。CMS 收集器需要统计之前每次垃圾收集的时间和老年代空间被消耗的速度。另外，如果老年代空间被消耗了 预设占用率（initiating occupancy），也将会触发一次垃圾收集，这个占用率通过`–XX:CMSInitiatingOccupancyFraction=n` 进行设置，n 为老年代空间的占用百分比，默认值是 68。
>这个数字到 Java8 的时候已经变为默认 92 了。如果老年代空间不足以容纳从新生代垃圾回收晋升上来的对象，那么就会发生 concurrent mode failure，此时会退化到发生 Full GC，清除老年代中的所有无效对象，这个过程是单线程的，比较耗时
  另外，即使在晋升的时候判断出老年代有足够的空间，但是由于老年代的碎片化问题，其实最终没法容纳晋升上来的对象，那么此时也会发生 Full GC，这次的耗时将更加严重，因为需要对整个堆进行压缩，压缩后年轻代彻底就空了。
  
  总结下来，和并行收集器相比，CMS 收集器降低了老年代收集时的停顿时间（有时是显著降低），稍微增加了一些年轻代收集的时间、降低了吞吐量 以及 需要更多的堆内存。
  
  ### G1收集器
  
  G1 的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量。G1 被设计用来长期取代 CMS 收集器，和 CMS 相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。区别在于，G1 没有 CMS 的碎片化问题（或者说不那么严重），同时提供了更加可控的停顿时间。
  
  如果你的应用使用了较大的堆（如 6GB 及以上）而且还要求有较低的垃圾收集停顿时间（如 0.5 秒），那么 G1 是你绝佳的选择，是时候放弃 CMS 了。
  
  #### G1概述
  
   G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。

![](/images/jvm/g1.png)

执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程并发执行，标记结束后，G1 也就知道哪些区块基本上是垃圾（存活对象极少），G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间.

在 G1 中，目标停顿时间非常非常重要，用 `-XX:MaxGCPauseMillis=200` 指定期望的停顿时间。

G1 使用了停顿预测模型来满足用户指定的停顿时间目标，并基于目标来选择进行垃圾回收的区块数量。G1 采用增量回收的方式，每次回收一些区块，而不是整堆回收。

#### G1工作流程
G1 收集器主要包括了以下 4 种操作：
1. 年轻代收集
2. 并发收集
3. 混合式垃圾收集
4. 必要时的 Full GC(应极力避免)

##### 年轻代收集

![](/images/jvm/g1-heap.png)

年轻代中的垃圾收集流程（Young GC）：
![](/images/jvm/g1-young-gc.png)

可以看到年轻代收集概念上和之前介绍的其他分代收集器大差不差的，但是它的年轻代会动态调整。

##### Old GC / 并发标记周期

把 Old GC 理解为并发周期是比较合理的，不要单纯地认为是清理老年代的区块，因为这一步和年轻代收集也是相关的。流程如下:
1. 初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。
2. 扫描根引用区：扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束(这个阶段不能发生年轻代收集，如果中途 Eden 区真的满了，也要等待这个阶段结束才能进行 Young GC)。
3. 并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断(这个阶段是并发执行的，中间可以发生多次 Young GC，Young GC 会中断标记过程)
4. 重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法(这个阶段会回收完全空闲的区块)。
5. 清理：清理阶段真正回收的内存很少

到这里，G1 的一个并发周期就算结束了，其实就是主要完成了垃圾定位的工作，定位出了哪些分区是垃圾最多的

##### 混合垃圾回收周期

并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。

混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。

##### Full GC

以下几种会导致 Full GC 的情况，是我们需要极力避免的：

1.concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。这个时候说明了:
- 堆需要增加了
- 或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束
- 或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期


2.晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。
>说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块

3.疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的(这个时候最简单的就是增加堆的大小)

4.大对象分配失败，我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象

#### G1参数配置

G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间，有以下几点我们可以进行调整的方向：
- 增加堆大小，或调整老年代和年轻代的比例
- 增加并发周期的线程数量，其实就是为了加快并发周期快点结束
- 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%）
- 在混合垃圾回收周期中回收更多的老年代区块


常用的参数:
- -XX:+UseG1GC(使用G1收集器)

- -XX:MaxGCPauseMillis=200(指定目标停顿时间，默认值 200 毫秒)

- -XX:InitiatingHeapOccupancyPercent=45(整堆使用达到这个比例后，触发并发 GC 周期，默认 45%)
> 可以通过调整这个数值，使并发周期提前进行, 降低晋升失败

- -XX:NewRatio=n(老年代/年轻代，默认值 2，即 1/3 的年轻代，2/3 的老年代)

- -XX:SurvivorRatio=n(Eden/Survivor，默认值 8，这个和其他分代收集器是一样的)

- -XX:MaxTenuringThreshold =n(从年轻代晋升到老年代的年龄阈值，也是和其他分代收集器一样的)

- -XX:ParallelGCThreads=n(并行收集时候的垃圾收集线程数)

- -XX:ConcGCThreads=n(并发标记阶段的垃圾收集线程数)
>增加这个值可以让并发标记更快完成，如果没有指定这个值，JVM 会通过以下公式计算得到：
ConcGCThreads=(ParallelGCThreads + 2) / 4^3

- -XX:G1HeapRegionSize=n

每一个 region 的大小，默认值为根据堆大小计算出来，取值 1MB~32MB，这个我们通常指定整堆大小就好了。




### 参考资料
- [g1垃圾收集器介绍](https://javadoop.com/post/g1)
- [java性能优化权威指南]