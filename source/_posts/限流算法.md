---
title: 限流算法
date: 2019-07-16 22:23:29
tags: 
categories: 架构
---

在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理

常用的限流算法有：令牌桶和漏桶算法


### 简介

#### 漏痛限流

![](/images/distributed/leaky-bucket.png)


漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了


#### 令牌桶限流

![](/images/distributed/token-bucket.png)

令牌桶算法是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞。

### Guava RateLimiter

`RateLimiter` 接口列表:

```java
public static RateLimiter create(double permitsPerSecond){}
public static RateLimiter create(double permitsPerSecond,long warmupPeriod,TimeUnit unit) {}

public double acquire() {}
public double acquire(int permits) {}

public boolean tryAcquire() {}
public boolean tryAcquire(int permits) {}
public boolean tryAcquire(long timeout, TimeUnit unit) {}
public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {}

public final double getRate() {}
public final void setRate(double permitsPerSecond) {}
```

RateLimiter 是用来限流， 再之前的文章中提到过 AQS 实现类 `Semaphore` 也能用来对资源进行控制， 两者不同的是`Semaphore`控制的是并发数量，`RateLimiter` 强调的是控制速率(比如控制每秒只能有 100 个请求通过)

它的构造方法指定一个 `permitsPerSecond` 参数，代表每秒钟产生多少个 permits，这就是速率


#### SmoothRateLimiter

抽象类 RateLimiter 目前只有一个子类，那就是抽象类 SmoothRateLimiter，SmoothRateLimiter 有两个实现类: 
`SmoothWarmingUp` 和 `SmoothBurty`。

RateLimiter 只有两个属性:
```java
// 用来计时，RateLimiter 把实例化的时间设置为 0 值，后续都是取相对时间，用微秒表示
private final SleepingStopwatch stopwatch;
// 用来作锁
private volatile Object mutexDoNotUseDirectly;
```

