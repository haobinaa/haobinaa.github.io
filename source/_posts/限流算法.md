---
title: 限流算法
date: 2019-07-16 22:23:29
tags: 
categories: 架构
---

在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理

常用的限流算法有：令牌桶和漏桶算法


### 简介

#### 漏痛限流

![](/images/distributed/leaky-bucket.png)


漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了


#### 令牌桶限流

![](/images/distributed/token-bucket.png)

令牌桶算法是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞。

### Guava RateLimiter

`RateLimiter` 接口列表:

```java
public static RateLimiter create(double permitsPerSecond){}
public static RateLimiter create(double permitsPerSecond,long warmupPeriod,TimeUnit unit) {}

public double acquire() {}
public double acquire(int permits) {}

public boolean tryAcquire() {}
public boolean tryAcquire(int permits) {}
public boolean tryAcquire(long timeout, TimeUnit unit) {}
public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {}

public final double getRate() {}
public final void setRate(double permitsPerSecond) {}
```

RateLimiter 是用来限流， 再之前的文章中提到过 AQS 实现类 `Semaphore` 也能用来对资源进行控制， 两者不同的是`Semaphore`控制的是并发数量，`RateLimiter` 强调的是控制速率(比如控制每秒只能有 100 个请求通过)

它的构造方法指定一个 `permitsPerSecond` 参数，代表每秒钟产生多少个 permits，这就是速率

抽象类 RateLimiter 目前只有一个子类，那就是抽象类 SmoothRateLimiter，SmoothRateLimiter 有两个实现类: 
`SmoothWarmingUp` 和 `SmoothBurty`。


#### SmoothRateLimiter

`SmoothBursty`处理突发流量，比如预设了1K/每秒的 permits

RateLimiter 只有两个属性:
```java
// 用来计时，RateLimiter 把实例化的时间设置为 0 值，后续都是取相对时间，用微秒表示
private final SleepingStopwatch stopwatch;
// 用来作锁
private volatile Object mutexDoNotUseDirectly;
```

抽象类 SmoothRateLimiter 的属性:
```java
// 当前还有多少 permits 没有被使用，被存下来的 permits 数量
double storedPermits;

// 最大允许缓存的 permits 数量，也就是 storedPermits 能达到的最大值
double maxPermits;

// 每隔多少时间产生一个 permit，
// 比如我们构造方法中设置每秒 5 个，也就是每隔 200ms 一个，这里单位是微秒，也就是 200,000
double stableIntervalMicros;

// 下一次可以获取 permits 的时间，这个时间是相对 RateLimiter 的构造时间的，是一个相对时间，理解为时间戳吧
private long nextFreeTicketMicros = 0L; 
```

他的内部实现大概是:

每次获取 `permits` 的时候，先拿 `storedPermits` 的值，如果够，`storedPermits` 减去相应的值就可以了，如果不够，那么还需要将 `nextFreeTicketMicros` 往前推，表示我预占了接下来多少时间的量了。那么下一个请求来的时候，如果还没到 `nextFreeTicketMicros` 这个时间点，需要 sleep 到这个点再返回，当然也要将这个值再往前推