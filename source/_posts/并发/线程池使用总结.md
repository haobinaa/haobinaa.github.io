---
title: 线程池使用详解
date: 2018-09-15 14:12:02
tags: 
categories: 并发
---
### 概述

使用线程时， 我们一般使用new Thread的方式, 如下:
``` 
new Thread(new Runnable() {

	@Override
	public void run() {
		// TODO Auto-generated method stub
	}
}).start();
```

这种方式有一些弊端：
- 每次new Thread新建对象性能差。
- 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom
- 缺乏更多功能，如定时执行、定期执行、线程中断

java提供了四种线程池，相较之下有如下好处：
- 重用存在的线程，减少对象创建、消亡的开销，性能佳
- 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞
- 提供定时执行、定期执行、单线程、并发数控制等功能

### Callable和Future

创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式的缺陷就是：在执行完任务之后无法获取执行结果。

#### Callable
Callable也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：
``` 
public interface Callable<V> {
    V call() throws Exception;
}
```
Callable一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：
``` 
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

#### Future

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

Future也是一个接口，定义如下
``` 
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

方法说明：
- cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数`mayInterruptIfRunning`表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论`mayInterruptIfRunning`为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若`mayInterruptIfRunning`设置为true，则返回true，若`mayInterruptIfRunning`设置为false，则返回false；如果任务还没有执行，则无论`mayInterruptIfRunning`为true还是false，肯定返回true

- isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true

- isDone方法表示任务是否已经完成，若任务完成，则返回true

- get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回

- get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null


#### FutureTask
因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了FutureTask

``` 
public class FutureTask<V> implements RunnableFuture<V>

public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值

FutureTask提供了2个构造器：
``` 
public FutureTask(Callable<V> callable) {
}
public FutureTask(Runnable runnable, V result) {
}
```

### 线程池实现架构
![](/images/Executor.png)

ThreadPoolExecutor实现了一般的线程池，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor的实现，然后增加了调度功能。

#### Executor
Executor，任务的执行者，线程池框架中几乎所有类都直接或者间接实现Executor接口，它是线程池框架的基础。Executor提供了一种将“任务提交”与“任务执行”分离开来的机制，它仅提供了一个Execute()方法用来执行已经提交的Runnable任务。

``` 
public interface Executor {
    void execute(Runnable command);
}
```

#### ExecutorService
ExecutorService提供了将任务提交给执行者的接口(submit方法)，让执行者执行任务(invokeAll, invokeAny方法)的接口等。

``` 
public interface ExecutorService extends Executor {

    /**
     * 启动一次顺序关闭，执行以前提交的任务，但不接受新任务
     */
    void shutdown();

    /**
     * 试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表
     */
    List<Runnable> shutdownNow();

    /**
     * 如果此执行程序已关闭，则返回 true。
     */
    boolean isShutdown();

    /**
     * 如果关闭后所有任务都已完成，则返回 true
     */
    boolean isTerminated();

    /**
     * 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行
     */
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future
     */
    <T> Future<T> submit(Callable<T> task);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future
     */
    <T> Future<T> submit(Runnable task, T result);

    /**
     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future
     */
    Future<?> submit(Runnable task);

    /**
     * 执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
        throws InterruptedException;

    /**
     * 执行给定的任务，当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表
     */
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    /**
     * 执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;

    /**
     * 执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果
     */
    <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

#### AbstractExecutorService

为ExecutorService的默认实现，AbstractExecutorService除了实现ExecutorService接口外，还提供了newTaskFor()方法返回一个RunnableFuture，在运行的时候，它将调用底层可调用任务，作为 Future 任务，它将生成可调用的结果作为其结果，并为底层任务提供取消操作

#### ScheduledExecutorService
继承ExecutorService，为一个“延迟”和“定期执行”的ExecutorService。他提供了一些如下几个方法安排任务在给定的延时执行或者周期性执行：

``` 
// 创建并执行在给定延迟后启用的 ScheduledFuture。
<V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit)

// 创建并执行在给定延迟后启用的一次性操作。
ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)

// 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；
//也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。
ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)

// 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。
ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
```

#### ThreadPoolExecutor
`ThreadPoolExecutor`继承于抽象类`AbstractExecutorService`， 是线程池的主要实现类

### 线程池实现原理
![](/images/threadpool_process.png)

#### 线程池处理流程
![](/images/threadpool_handle_process.png)

excute流程：
1. 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。
 
2. 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。
 
3. 如果无法将任务加入BlockingQueue（队列已满），则在非corePool中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 

4. 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 
RejectedExecutionHandler.rejectedExecution()方法。 


##### 线程池饱和策略

- AbortPolicy: 为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出

- DiscardPolicy: 直接抛弃，任务不执行，空方法

- DiscardOldestPolicy： 从队列里面抛弃head的一个任务，并再次execute 此task

- CallerRunsPolicy： 在调用execute的线程里面执行此command，会阻塞入口

- 用户自定义拒绝策略（最常用）：实现RejectedExecutionHandler，并自己定义策略模式 


### 源码分析


#### ctl变量

ThreadPoolExcuter是将两个内部值打包成一个值，即将workerCount和runState（运行状态）这两个值打包在一个ctl中，因为runState有5个值，需要3位，所以有3位表示runState，而其他29位表示为workerCount。而运行时要获取其他数据时，只需要对ctl进行拆包即可。
``` 
    // 与0做 |运算， 求出前三位状态位
   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3; 
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;  // 2^29-1

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;  // 111
    private static final int SHUTDOWN   =  0 << COUNT_BITS; // 000
    private static final int STOP       =  1 << COUNT_BITS; // 001
    private static final int TIDYING    =  2 << COUNT_BITS; // 010
    private static final int TERMINATED =  3 << COUNT_BITS; // 100

    // Packing and unpacking ctl  　　//拆包ctl，分别获取runState和WorkerCount
    private static int runStateOf(int c)     { return c & ~CAPACITY; } // 取前三位状态位， ~CAPATITY为29个1
    private static int workerCountOf(int c)  { return c & CAPACITY; }　　// 取线程数
    private static int ctlOf(int rs, int wc) { return rs | wc; } // 拼出状态和线程数
```

#### 关键的类成员
``` 
  private final BlockingQueue<Runnable> workQueue;  // 任务队列，我们的任务会添加到该队列里面，线程将从该队列获取任务来执行

   private final HashSet<Worker> workers = new HashSet<Worker>();//任务的执行值集合，来消费workQueue里面的任务

   private volatile ThreadFactory threadFactory;//线程工厂

   private volatile RejectedExecutionHandler handler;//拒绝策略，默认会抛出异异常，还要其他几种拒绝策略如下：

   1、CallerRunsPolicy：在调用者线程里面运行该任务
   2、DiscardPolicy：丢弃任务
   3、DiscardOldestPolicy：丢弃workQueue的头部任务

  private volatile int corePoolSize;//最下保活work数量

  private volatile int maximumPoolSize;//work上限
```

#### execute流程
execute源码:
``` 
 public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        //表示 “线程池状态” 和 “线程数” 的整数
        int c = ctl.get();
        // 如果当前线程数少于核心线程数，直接添加一个 worker 执行任务，
        // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)
        if (workerCountOf(c) < corePoolSize) {
        // 添加任务成功，即结束
        // 执行的结果，会包装到 FutureTask 
        // 返回 false 代表线程池不允许提交任务
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }

        // 到这说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败
  
        // 如果线程池处于 RUNNING ，把这个任务添加到任务队列 workQueue 中
        if (isRunning(c) && workQueue.offer(command)) {
            /* 若任务进入 workQueue，我们是否需要开启新的线程
             * 线程数在 [0, corePoolSize) 是无条件开启新线程的
             * 若线程数已经大于等于 corePoolSize，则将任务添加到队列中，然后进到这里
             */
            int recheck = ctl.get();
            // 若线程池不处于 RUNNING ，则移除已经入队的这个任务，并且执行拒绝策略
            if (! isRunning(recheck) && remove(command))
                reject(command);
            // 若线程池还是 RUNNING ，且线程数为 0，则开启新的线程
            // 这块代码的真正意图：担心任务提交到队列中了，但是线程都关闭了
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 若 workQueue 满，到该分支
        // 以 maximumPoolSize 为界创建新 worker，
        // 若失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略
        else if (!addWorker(command, false))
            reject(command);
}
```

#### addWorker流程

addWorker源码流程:
1. 检查是否可以根据当前池状态和给定的边界（核心或最大)
2. 添加新工作线程。如果是这样,工作线程数量会相应调整，如果可能的话,一个新的工作线程创建并启动
3. 将firstTask作为其运行的第一项任务。
4. 如果池已停止此方法返回false
5. 如果线程工厂在被访问时未能创建线程,也返回false
6. 如果线程创建失败，或者是由于线程工厂返回null，或者由于异常（通常是在调用Thread.start（）后的OOM）），我们干净地回滚

```java
 private boolean addWorker(Runnable firstTask, boolean core) {
        // java标签
        retry:
        // 死循环
        for (;;) {
            int c = ctl.get();
            // 获取当前线程状态和线程数
            int rs = runStateOf(c);
            
            // 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：
            // 1. 线程池状态大于 SHUTDOWN， 其实就是 STOP, TIDYING, 或 TERMINATED， 代表线程池状态为关闭
            // 2. firstTask != null
            // 3. workQueue.isEmpty()
            // 原因：
            // 当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行
            // 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务
            // 如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的
            // 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完
            // 所以在满足条件的基础上，是允许创建新的 Worker 的
            if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN && 
            firstTask == null &&
            !workQueue.isEmpty()))
                return false;
            
            
            // 如果线程池状态为RUNNING并且队列中还有需要执行的任务
            for (;;) {
                // 获取线程池中线程数量
                int wc = workerCountOf(c);
                // 检测是否满足创建线程的条件
                if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了
                // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程
                if (compareAndIncrementWorkerCount(c))
                    // 跳出retry
                    break retry;
                // 由于有并发，重新再读取一下 ctl
                c = ctl.get();  
                // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了
                // 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池
                // 那么需要回到外层的for循环
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        // 走到这里说明工作线程数增加成功，所有的校验都通过了
        
        // worker 是否启动
        boolean workerStarted = false;
        // 是否将这个 worker 添加到 workers 这个 HashSet 中
        boolean workerAdded = false;
        Worker w = null;
        try {
            final ReentrantLock mainLock = this.mainLock;
            // 把 firstTask 传给 worker 的构造方法
            w = new Worker(firstTask);
            // 取 worker 中的线程对象
            final Thread t = w.thread;
            if (t != null) {
                // 这个是整个线程池的全局锁
                // 因为关闭一个线程池需要这个锁，至少持有锁的期间，线程池不会被关闭
                mainLock.lock();
                try {
                    int c = ctl.get();
                    int rs = runStateOf(c);
                     // 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况
                     // 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        // 检查线程状态，不能是已经启动的
                        if (t.isAlive()) 
                            throw new IllegalThreadStateException();
                        // 将新启动的线程添加到线程池中
                        workers.add(w);
                        // 更新线程池线程数且不超过最大值
                        int s = workers.size();
                        // largestPoolSize 用于记录 workers 中的个数的最大值
                        // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                // 如果添加成功，启动线程
                if (workerAdded) {
                    // 启动 worker 线程， 调用 run()
                    // 里面的方法是： runWorker()
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            //  // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉
            if (! workerStarted)
                // workers 删除对应的 worker
                // workerCount 减1
                addWorkerFailed(w);
        }
        // 返回线程是否启动成功
        return workerStarted;
    }
```

#### 工作线程-runWorker流程

```java
// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行
// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取
 final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        // 该线程的第一个任务(若有)
        Runnable task = w.firstTask;
        w.firstTask = null;
        // 允许中断
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            // 循环调用 getTask 获取任务
            while (task != null || (task = getTask()) != null) {
                // 先将 worker 锁起来
                w.lock();
                 // 若线程池状态大于等于 STOP，那么意味着该线程也要中断
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                
                
                try {
                // 这是一个钩子方法，留给需要的子类实现
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                    // 执行任务
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        // 将 Throwable 转换成 Error
                        thrown = x; throw new Error(x);
                    } finally {
                        // 同样是个钩子方法
                        afterExecute(task, thrown);
                    }
                } finally {
                    // 置空 task，准备 getTask 获取下一个任务
                    task = null;
                    // 累加完成的任务数
                    w.completedTasks++;
                    // 释放掉 worker 的独占锁
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            // 到这里，需要执行线程关闭：
             // 1. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭
             // 2. 任务执行过程中发生了异常
            processWorkerExit(w, completedAbruptly);
        }
    }
```

##### getTask获取任务流程
```java
// 此方法有三种可能
// 1. 阻塞直到获取到任务返回。默认 corePoolSize 之内的线程是不会被回收的，它们会一直等待任务
// 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭
// 3. 如果发生了以下条件，须返回 null
//     - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)
//     - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务
//     - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            // 两种可能
            // 1. rs == SHUTDOWN && workQueue.isEmpty()
            // 2. rs >= STOP
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                // CAS 操作，减少工作线程数
                decrementWorkerCount();
                // 返回null
                return null;
            }
             boolean timed;      // Are workers subject to culling?
             for (;;) {
                int wc = workerCountOf(c);
                // 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭
                timed = allowCoreThreadTimeOut || wc > corePoolSize;
                
                 // 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))
                 // 两个 if 一起看：如果当前线程数 wc > maximumPoolSize，或者超时，都返回 null
                 // wc > maximumPoolSize 的情况，为什么要返回 null？
                 // 返回null意味关闭线程
                 // 有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭
                if (wc <= maximumPoolSize && ! (timedOut && timed))
                    break;
                if (compareAndDecrementWorkerCount(c))
                    return null;
                c = ctl.get();  // Re-read ctl
                // compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变
                if (runStateOf(c) != rs)
                    continue retry;
            }
             try {
                 // 到 workQueue 中获取任务
                 Runnable r = timed ?
                     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                     workQueue.take();
                 if (r != null)
                     return r;
                 timedOut = true;
             } catch (InterruptedException retry) {
                 // 如果此 worker 发生了中断，采取的方案是重试
                 // 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法。
                 // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，
                 // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null
                 timedOut = false;
             }
        }
    }
```
Worker执行流程：

![](/images/workerProcess.png)


### 线程池使用的缓存队列(workQueue)

缓冲队列的长度决定了能够缓冲的最大数量，缓冲队列有三种通用策略：
1. 直接提交
2. 无界队列
3. 有界队列

#### 直接提交(SynchronousQueue)

工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。 

在此，如果不存在可用于立即运行任务的线程，则把任务加入队列将失败，因此会构造一个新的线程。

此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; 

##### 使用示例

首先SynchronousQueue是无界的，也就是说他存储任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。

使用如下:
``` 
new ThreadPoolExecutor(   
                2, 3, 30, TimeUnit.SECONDS,    
                new  SynchronousQueue<Runnable>(),    
                new RecorderThreadFactory("CookieRecorderPool"),    
                new ThreadPoolExecutor.CallerRunsPolicy());
```

假设当前核心线程已经有2个正在运行:
1. 此时来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。
2. 又来了一个任务（B），且核心2个线程还没有忙完。接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。
3. 此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程”，所以必然会新建一个线程来运行这个任务。
4. 但是如果这三个任务都还没完成，继续来了一个任务，queue中无法插入（任务A还在queue中），而线程数达到了maximumPoolSize，所以只好执行异常策略了。 

为了避免这种情况:，所以在使用SynchronousQueue通常要求maximumPoolSize是无界的（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁

#### 无界队列(LinkedBlockingQueue)

使用无界队列（例如 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时，新任务将在队列中等待。这样，创建的线程数量就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）

当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性; 

##### 使用示例

拿newFixedThreadPool来说:
1. 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队
2. 如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程
3. 正常情况下当无法加入队列时就创建新的线程，但无界队列不会出现无法加入队列的情况(资源耗尽另算)。换句说，永远也不会触发产生新的线程！线程数一直都是corePoolSize大小。忙完当前的线程，就从队列中拿任务开始运行。如果任务运行的时长比较长，而添加任务的速度远远超过处理任务的速度，任务队列就会疯长，任务内存很快就会爆掉

#### 有界队列(ArrayBlockingQueue)

当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。

队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量.

##### 使用示例

这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。

例如:
``` 
new ThreadPoolExecutor(  
            2, 4, 30, TimeUnit.SECONDS,   
            new ArrayBlockingQueue<Runnable>(2),   
            new RecorderThreadFactory("CookieRecorderPool"),   
            new ThreadPoolExecutor.CallerRunsPolicy());  
```
假设，所有的任务都永远无法执行完:
1. 首先来的A,B直接运行
2. 如果来了C,D，他们会被放到queue中
3. 如果接下来再来E,F，则增加线程运行E，F。最大线程数是4
4. 但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理

### 线程池的使用

#### 创建线程池

我们可以通过ThreadPoolExecutor来创建一个线程池:
``` 
 public ThreadPoolExecutor(int corePoolSize,
               int maximumPoolSize,
               long keepAliveTime,
               TimeUnit unit,
               BlockingQueue<Runnable> workQueue) {
        // threadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
                Executors.defaultThreadFactory(), defaultHandler);
    }
```

各个参数含义：
-  corePoolSize： 线程池基本大小，核心线程池大小，活动线程小于corePoolSize则直接创建，大于等于则先加到workQueue中，队列满了才创建新的线程。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。

- maximumPoolSize：最大线程数，超过就reject；线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。

- keepAliveTime：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率(创建线程的开销比较大)

- unit：线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）

- workQueue：工作队列，线程池中的工作线程都是从这个工作队列源源不断的获取任务进行执行



#### 合理的配置线程池

要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析:

- 任务的性质：CPU密集型任务、IO密集型任务和混合型任务

性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。

- 任务的优先级：高、中和低

优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行 
如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。

- 任务的执行时间：长、中和短

执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。

- 任务的依赖性：是否依赖其他系统资源，如数据库连接

依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。 
建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有时候我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。





### 参考资料

- [J.U.C之线程池](http://cmsblogs.com/?p=2444)
- [线程池使用总结](https://juejin.im/post/5a37944ef265da432b4aec03)
- [java线程池原理及分析](https://blog.csdn.net/fuyuwei2015/article/details/72758179)
- [线程池源码分析-使用总结](https://cloud.tencent.com/developer/article/1124439)
- [java线程池拒绝策略](https://blog.csdn.net/pozmckaoddb/article/details/51478017)
- [java线程池原理和队列详解](https://blog.csdn.net/xx326664162/article/details/51701508)