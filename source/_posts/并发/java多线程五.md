---
title: java多线程(Java内存模型一)
date: 2017-11-23 19:15:21
tags: java多线程
categories: java并发
---
#### 操作系统语义(缓存一致性)
计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。   
有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。这样就会出现问题，比如:
```
i++i++
```
当线程运行这段代码时，首先会从主存中读取i( i = 1)，然后复制一份到CPU高速缓存中，然后CPU执行 + 1 （2）的操作，然后将数据（2）写入到告诉缓存中，最后刷新到主存中结果是3。  
在单线程中是没问题的，如果是多线程呢，假如A、B两个线程，两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。这种现象就是缓存一致性的问题。  
解决方案如下：
1. 通过在总线加LOCK锁的方式
2. 通过缓存一致性协议
方案一如果是给总线加锁，那么就只有一个CPU能运行，其他CPU都会阻塞，效率较低  
方案二，缓存一致性协议：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。

#### java内存模型
并发编程有三个概念：原子性，可见性，有序性

##### 原子性
>一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

原子性就跟数据库的事务一样，是不可打断的。例如：
``` 
i = 0;  //原子性，对基本数据类型的变量赋值都是原子性操作
j = i ; //包含两个操作，读取i，将i赋给j
i++;    //三个操作，读取i,i+1,将+1的结果赋值给i
i = j + 1; //三个操作，读取j，j+1，j+1的结果赋值给i
```
在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：在32位的JDK环境下，对64位数据的读取不是原子性操作，如long、double）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。

##### 可见性
>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

Java提供了volatile来保证可见性。当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。 
 synchronize和锁都可以保证可见性。
 
 ##### 有序性
 >即程序执行的顺序按照代码的先后顺序执行。
 
 在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。  
 Java提供volatile来保证一定的有序性。
 
 #### volatile
 > volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的
 
 一个变量如果用volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。
 
 可以看出volatile的两个功能:
 1. 保证可见性，不保证原子性
 2. 禁止指令重排序
 
 ##### 指令重排序
 在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：
 1. 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
 2. 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
 
 ##### happens-before内存模型
 happens-before来阐述多线程之间的内存可见性：
 >在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
 
 例如:
 ```
 x = 1;     //线程A执行
 j = x;     //线程B执行
 ```
 j如果要满足等于1，假设线程A的操作(x=1)happens-before线程B操作，那么可以确定线程B执行后一定有j等于1，如果他们不存在happens-before原则，那么j=1不一定成立。happens-before定义如下：
 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
 2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法
 
 happens-before原则：
 1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
 2. 锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作；
 3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
 4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
 5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
 6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
 7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
 8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；
 
 #### 内存屏障
 通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行
 
 
 | 屏障类型 | 指令示例 | 说明 |
 | ----     |:-----|:----------- |
 | LoadLoad Barriers   | Load1; LoadLoad; Load2 | 确保Load1数据的装载之前于Load2及所有后续装载指令的装载。 |
 | StoreStore Barriers | Store1; StoreStore; Store2 | 确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储 |
 | LoadStore Barriers | Load1; LoadStore; Store2 | 确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。|
 | StoreLoad Barriers | Store1; StoreLoad; Load2 | 确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令 |
 