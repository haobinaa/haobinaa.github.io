---
title: java内存模型和volatile
date: 2018-06-25 21:18:15
tags:
categories: 并发
---
### java内存模型

#### java内存模型的主要目标

Java 内存模型的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中 将变量存储到内存 和 从内存中取出变量 这样的底层细节。此处的变量（Variables）与 Java 变成中所说的变量有所区别，它包括了实例变量、静态变量和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

#### 工作内存和主内存

Java 内存模型规定了所有的变量都存储在主内存（Main Memory， 这里指的是虚拟机内存的一部分）中。每条线程还有自己的工作内存（Working Memory，可以与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示

![](/images/work_memory.png)

这里说的主内存、工作内存和 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本是没有关系的，如果两者一定要勉强对应起来的话，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于 Java 虚拟机栈中的部分区域

#### 内存交互操作

关于 主内存 和 工作内存 之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了一下 8 中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，在某些平台上允许有例外，这个问题将在下文中说明）。

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用
- load（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值保存到工作内存的变量副本中
- use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎（一般是基于操作数栈的执行引擎），每当虚拟机遇到一个需要使用到该变量的值的 字节码指令时将会执行这个操作
- assign（赋值）：作用于工作内存的变量，它把从执行引擎接收到的值赋值给工作内存的变量（存放在局部变量表中），每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- store（存储）：作用于工作内存的变量，它把工作内存中的变量传送到主内存中，以便随后的 write 操作使用
- write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值方法主内存的变量中

其中 read、load、use、assign、store 和 write 这 6 种操作的关系如下图所示：

![](/images/swamp_memory.png)

java 内存模型规定了在执行上述 8 中基本操作时必须满足如下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起会回写了但主内存不接受的情况出现
- 不允许一个现场丢弃它的最近的 assign 操作，即变量的值在工作内存改变了以后必须把该变化同步到主内存中。
