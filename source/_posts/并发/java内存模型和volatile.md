---
title: java内存模型和volatile
date: 2018-05-25 21:18:15
tags:
categories: 并发
---
### 线程安全
谈谈线程安全

对于Java并发编程，一般来说有以下的关注点：

1. 线程安全性，正确性。
2. 线程的活跃性(死锁，活锁)
3. 性能

对于线程安全，本质上就是保证线程同步，实际上就是线程之间的通信问题。在操作系统中，线程通信有以下几种方式：
1. 信号量
2. 信号
3. 管道 
4. 共享内存
5. 消息队列
6. socket


### java中线程通信
java中线程通信主要使用共享内存的方式。共享内存的通信方式首先要关注的就是可见性和有序性。而原子性操作一般都是必要的

#### 原子性 
原子性是指操作是不可分的。其表现在于对于共享变量的某些操作，应该是不可分的，必须连续完成。例如a++，对于共享变量a的操作，实际上会执行三个步骤，1.读取变量a的值  2.a的值+1  3.将值赋予变量a 。 这三个操作中任何一个操作过程中，a的值被人篡改，那么都会出现我们不希望出现的结果。所以我们必须保证这是原子性的。Java中的锁的机制解决了原子性的问题。

#### 有序性
有序性涉及到指令重排序

#### 可见性
可见性涉及到java的内存模型

### java内存模型

#### java内存模型的主要目标

Java 内存模型的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中 将变量存储到内存 和 从内存中取出变量 这样的底层细节。此处的变量（Variables）与 Java 变成中所说的变量有所区别，它包括了实例变量、静态变量和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

#### 工作内存和主内存

Java 内存模型规定了所有的变量都存储在主内存（Main Memory， 这里指的是虚拟机内存的一部分）中。每条线程还有自己的工作内存（Working Memory，可以与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示

![](/images/work_memory.png)

这里说的主内存、工作内存和 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本是没有关系的，如果两者一定要勉强对应起来的话，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于 Java 虚拟机栈中的部分区域

#### 内存交互操作

关于 主内存 和 工作内存 之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了一下 8 中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，在某些平台上允许有例外，这个问题将在下文中说明）。

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用
- load（载入）：作用于工作内存的变量，它把 read 操作从主内存得到的变量值保存到工作内存的变量副本中
- use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎（一般是基于操作数栈的执行引擎），每当虚拟机遇到一个需要使用到该变量的值的 字节码指令时将会执行这个操作
- assign（赋值）：作用于工作内存的变量，它把从执行引擎接收到的值赋值给工作内存的变量（存放在局部变量表中），每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- store（存储）：作用于工作内存的变量，它把工作内存中的变量传送到主内存中，以便随后的 write 操作使用
- write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值方法主内存的变量中

其中 read、load、use、assign、store 和 write 这 6 种操作的关系如下图所示：

![](/images/swamp_memory.png)

java 内存模型规定了在执行上述 8 中基本操作时必须满足如下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起会回写了但主内存不接受的情况出现
- 不允许一个现场丢弃它的最近的 assign 操作，即变量的值在工作内存改变了以后必须把该变化同步到主内存中。
- 不允许一个线程无原因的（没有发生过任何 assing 操作）把数据从线程的工作内存同步回主内存中
- 个新的变量只能在主内存中“诞生”，不允许在工作内存使用一个未被初始化（load 或 assing）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过 assign 和 load 操作
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 之后，只有执行相同次的 unlock 操作，变量才会被解锁。
- 如果对一个变量进行 lock 操作，那么将会清空工作内存中这个变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量
- 对一个变量执行 unlock 之前，必须先把此变量同步回主内存中（执行 store 以及 write 操作）

### volatile


#### 重排序

在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：

1. 在单线程环境下不能改变程序运行的结果；
2. 存在数据依赖关系的不允许重排序


#### happens-before原则

如果 Java 内存模型中所有的有序性都仅仅靠 volatile 和 synchronized 来完成，那么有一些操作将会变得很烦琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个 “先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

下面是 Java 内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码 
中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意的进行重排序：

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准备的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构

- 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。

- volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序

- 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每一个动作

- 线程终止规则：线程中的所有操作都先行于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thead.isAlive() 的返回值等手段检测到线程已经终止执行

- 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生

- 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行于发生于它的 finalized() 方法的开始

- 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论

#### volatile作用

当一个变量定义为 volatile 之后，它将具备两种特性：**保证变量的可见性** 和 **禁止指令重排序优化**

- 第一个是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程改变了这个变量的值，新值对于其他线程来说是 立即得知 的。而普通变量做不到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改了一个普通变量的值，然后向主内存进行回写，另外一个线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量才会对线程 B 可见

- 使用 volatile 变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致


#### volatile的内存语义

- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中。
- 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量

