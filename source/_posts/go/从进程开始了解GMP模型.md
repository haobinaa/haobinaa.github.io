---
title: 从进程开始了解GMP模型
date: 2023-06-05 11:57:13
tags: gmp
categories: go
---

###  进程和线程

进程是操作系统分配资源(CPU、内存、文件)、调度任务和执行的一个基本单位。它拥有独立的内存空间、已分配的资源和独立的执行上下文。
线程是CPU调度的基本单位，同一进程内的线程共享了进程的资源和内存空间。

系统将内存分为两个区域:
- 内核空间（Kernal Space）: 内核空间是指用于运行操作系统内核、驱动程序等低级系统组件的特殊内存区域。在这个区域中，代码拥有对硬件的完全访问权限，包括传感器、内存、CPU 等。
- 用户空间（User Space）：用户空间指的是应用程序和相关库运行的内存区域。在这个区域中，代码受到了更严格的保护措施，以防止对硬件的不当访问。用户空间中的应用程序必须通过系统调用（System Call）与内核空间进行交互，以获得内核提供的服务，如内存分配、输入/输出操作等。

由于内核态具有非常高的权限， 用户空间的代码被限制在一个局部的内存空间， 也就是用户态(User Mode)， 内核空间的代码能够访问所有的内存,  在内核空间的程序也被称为内核态(Kenranl Mode)

用户态切换内核态: 
内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。当发生系统调用时，用户态的程序发起系统调用。因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调.用。内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。

### 用户线程、内核线程和轻量级进程(LWP)

如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。

很多同学会以为: 用户态的进程创建用户态的线程，内核态的进程创建内核态的线程。其实不是， 进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。

#### 用户态线程

用户态线程（User Level Thread）:是一种完全由用户空间库（如线程库 Posix Pthreads）管理的线程实现。这种线程实现与操作系统内核相互独立，操作系统无法直接感知和调度这些线程。纯用户态线程仅在用户级别进行调度、上下文切换和同步操作，没有内核级别的干预。

优点:
- **管理开销小**：创建、销毁不需要系统调用。
- **切换成本低**：用户空间程序可以自己维护，不需要走操作系统调度。

缺点:
- **与内核协作成本高**：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。
- **线程间协作成本高**：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。
- **无法利用多核优势**：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。
- **操作系统无法针对线程调度进行优化**：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。

#### 内核态线程

内核态线程（Kernel Level Thread）：这种线程执行在内核态，可以通过系统调用创造一个内核级线程。

优点:
- **可以利用多核 CPU 优势**：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。
- **操作系统级优化**：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。

缺点:
- **创建成本高**：创建的时候需要系统调用，也就是切换到内核态。
- **扩展性差**：由一个内核程序管理，不可能数量太多。
- **切换成本较高**：切换的时候，也同样存在需要内核操作，需要切换内核态

#### LWP(轻量级进程)

首先理解一个概念 `内核态调度实体（Kernel-level scheduling entity）`：是指在操作系统内核空间运行、被操作系统内核调度器管理的任务执行单位。在这种情况下，调度实体通常指的是线程（如内核线程）或轻量级进程（LWP）。

LWP 是 Linux （Solaris）系统中内核态调度实体的一种实现， 和内核线程都是以 `task_struct` 结构体表示， 具体两者的区别:
-  **内核线程（Kernel Thread）**：内核线程是运行在内核空间的线程，直接被内核管理，用于处理核心系统任务，如中断处理、设备驱动等。内核线程并不与用户空间的程序相关联，而只服务于操作系统内核。
- **轻量级进程（LWP）**：Linux 中的 LWP 可以与 POSIX 线程 (Pthread 或用户线程) 联系起来。LWPs 由操作系统内核管理，它们运行在用户空间，可以执行用户程序。在 Linux 中，每个 LWP 对应一个唯一的内核态调度实体，有着独立的上下文切换信息。

另外LWP运行在用户态还是内核态呢？

轻量级进程（LWP）通常是用户空间线程（如 POSIX 线程）和内核态调度实体之间的桥梁。从这个角度来看，LWP 既有用户态特性，又与内核态调度实体关联。但整体上说，LWP 更多地处于内核态。

在用户态，LWP 与用户级线程（如 POSIX 线程）关联，它们共享代码、数据以及操作系统资源。然而，在内核中，每个 LWP 都关联着一个唯一的内核态调度实体，负责管理 LWP 的状态、资源和调度信息等。当用户线程需要进行系统调用时，操作系统接管控制权并将执行切换到内核态。

在 Linux 系统中， POSIX 线程和 LWP 的实现已经高度集成，LWP 可以直接与内核态调度实体关联，由操作系统内核进行调度和管理。因此，在这种上下文中，LWP 主要运行在内核态，负责管理和调度用户线程与内核态调度实体之间的映射关系。

### 线程模型

线程简单理解，就是要执行一段程序。程序不会自发的执行，需要操作系统进行调度。

如果要让一个拥有多个线程的用户态进程去执行， 最先想到的就是让一个内核线程去执行这个进程， 毕竟内核线程是真正的线程，因为它会分配到 CPU 的执行资源。

这样所有的线程都需要自己去调度， 相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。

这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。

**用户态线程创建成本低，问题明显，不可以利用多核。内核态线程，创建成本高，可以利用多核，切换速度慢**。因此通常我们会在内核中预先创建一些线程，并反复利用这些线程。这样，用户态线程和内核态线程之间就构成了3 种主流模型：

#### 多对一（Many to One）

用户态进程中的多线程复用一个内核态线程。这样，极大地减少了创建内核态线程的成本，但是线程不可以并发(本质上只有一个内核)。因此，这种模型现在基本上用的很少

#### 一对一（One to One）

该模型为每个用户态的线程分配一个单独的内核态线程，在这种情况下，每个用户态都需要通过系统调用创建一个绑定的内核线程，并附加在上面执行。 这种模型允许所有线程并发执行，能够充分利用多核优势，Windows NT 内核采取的就是这种模型。但是因为线程较多，对内核调度的压力会明显增加。

#### 多对多（Many To Many）

这种模式下会为 n 个用户态线程分配 m 个内核态线程。m 通常可以小于 n。一种可行的策略是将 m 设置为核数。这种多对多的关系，减少了内核线程，同时也保证了多核心并发。Linux 目前采用的就是该模型。



### GO GMP 调度模型

GO 采取 GMP来解决传统内核级线程的创建、切换、销毁开销大的问题， 其中:

- G:  Goroutine的缩写，用户态、轻量级的协程，一个 G 代表了对一段需要被执行的 Go 语言程序的封装；每个 Goroutine 都有自己独立的栈存放自己程序的运行状态上下文；分配的栈大小 2KB，可以按需扩缩容
- M: Machine的缩写，代表了内核线程 OS Thread，CPU调度的基本单元；
- P: processor的缩写，代表一个虚拟的处理器，它维护一个局部的可运行的 G 队列，可以通过 CAS 的方式无锁访问，工作线程 M 优先使用自己的局部运行队列中的 G，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了大量 G 的并发性。每个 G 要想真正运行起来，首先需要被分配一个 P。


可运行的 G 是通过处理器 P 和线程 M 绑定起来的，M 的执行是由操作系统调度器将 M 分配到 CPU 上实现的，Go 运行时调度器(也叫  Goroutine 调度器， 负责)负责调度 G 到 M 上执行，主要在用户态运行，跟操作系统调度器在内核态运行相对应。
整体如下图所示:

![](/images/go/gmp.jpeg)

Goroutine 调度器负责将 G 高效的调度到 M 上去执行， 核心思想是:

1. 尽可能复用线程 M：避免频繁的线程创建和销毁；

2. 利用多核并行能力：限制同时运行（不包含阻塞）的 M 线程数为 N，N 等于 CPU 的核心数目，这里通过设置 P 处理器的个数为 GOMAXPROCS 来保证，GOMAXPROCS 一般为 CPU 核数，因为 M 和 P 是一一绑定的，没有找到 P 的 M 会放入空闲 M 列表，没有找到 M 的 P 也会放入空闲 P 列表；

3. Work Stealing 任务窃取机制：M 优先执行其所绑定的 P 的本地队列的 G，如果本地队列为空，可以从全局队列获取 G 运行，也可以从其他 M 偷取 G 来运行；为了提高并发执行的效率，M 可以从其他 M 绑定的 P 的运行队列偷取 G 执行，这种 GMP 调度模型也叫任务窃取调度模型，这里，任务就是指 G；

4. Hand Off 交接机制：M 阻塞，会将 M 上 P 的运行队列交给其他 M 执行，交接效率要高，才能提高 Go 程序整体的并发度；

5. 基于协作的抢占机制：每个真正运行的G，如果不被打断，将会一直运行下去，为了保证公平，防止新创建的 G 一直获取不到 M 执行造成饥饿问题，Go 程序会保证每个 G 运行10ms 就要让出 M，交给其他 G 去执行；

6. 基于信号的真抢占机制：尽管基于协作的抢占机制能够缓解长时间 GC 导致整个程序无法工作和大多数 Goroutine 饥饿问题，但是还是有部分情况下，Go调度器有无法被抢占的情况，例如，for 循环或者垃圾回收长时间占用线程，为了解决这些问题， Go1.14 引入了基于信号的抢占式调度机制，能够解决 GC 垃圾回收和栈扫描时存在的问题。





