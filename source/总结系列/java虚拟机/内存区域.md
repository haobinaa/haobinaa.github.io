### 概述
java虚拟机实现了内存管理，不需要手动去new或free，不容易出现内存泄露，但是如果出现了内存泄露，不了解虚拟机，就难以定位到问题所在

java内存区域如图所示：
![](http://oi46mo3on.bkt.clouddn.com/10_deep_in_jvm/jvm_runtime_data_area.png)

#### 程序计数器

程序计数器可以简单理解为线程执行字节码的行号指示器。由于在线程切换后需要恢复到程序的执行位置，因此每个线程都有各自的程序计数器

特点：
- 一块较小的内存，可以看作是当前线程所执行的字节码的行号指示器
- 在虚拟机概念模型（各种虚拟机实现可能不一样）中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 程序计数器是属于线程私有的内存
- 如果执行的是Java方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法则为空

#### java虚拟机栈

- java虚拟机栈为线程私有
- 描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
- 局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型；其所需的内存空间在编辑期完成分配，不会再运行期改变
- Java虚拟机规范对此区域规定了两种异常情况：当线程请求的栈深度大于虚拟机允许的最大深度将触发StackOverflowError；如果虚拟机栈在动态扩展时无法申请到足够的内存将触发OutOfMemoryError

#### 本地方法栈
- 与虚拟机栈非常相似，只不过是为虚拟机使用到的Native方法服务
- 可能存在两种异常：StackOverflowError和OutOfMemoryError


#### java堆
- Java堆是被所有线程共享的，在虚拟机启动时创建

- 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这分配

- 是垃圾收集器管理的主要区域，可以分为新生代和老年代

- 可以物理不连续，只要逻辑上是连续的即可

- 如果堆中没有内存完成实例分配也无法再扩展时，会抛出OutOfMemoryError异常

#### 方法区
- 是线程共享的区域；

- 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

- 该区域对于垃圾收集来说条件比较苛刻，但是还是非常有必要要进行回收处理(jdk8之前被称为永久代，jdk8后改为元空间，会被gc回收)

##### 运行时常量池

- 是方法区的一部分

- Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放

- Java虚拟机规范要求较少，通常还会把翻译出来的直接引用也存储在此

- 另外一个重要特征是具备动态性，可以在运行期间将新的常量放入池中，如String的intern方法
- 可能存在的异常：OutOfMemoryError

#### 直接内存
- 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域；

- JDK 1.4的NIO引入了基于通道（Channel）和缓冲区（Buffer）的IO方法，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作以提升性能


### java对象

#### 对象的创建过程

- 虚拟机遇到一条new指令时，先检查指令的参数是否能在常量池中定位到一个类的符号，并且检查这个符号引用代码的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程

- 接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便完全确定，为对象分配空间等同于把一块确定大小的内存从Java堆中划分出来。在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞（内存绝对规整，只要通过指针作为分界点标识）；而使用CMS这种基于Mark-Sweep算法收集器时，通常使用空闲列表（内存不规整，通过维护一个列表记录那块内存是可用的）

- 另外一个需要考虑的并发下的线程安全问题，有两种方案：一是分配内存空间的动作进行同步处理（实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；二是为每个线程分配一小块内存（称为本地线程分配缓冲，TLAB），各个线程独立分配，只有TLAB用完需要分配新的才需要同步锁定，虚拟机通过-XX:+/-UseTLAB参数来设定

- 内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段数据类型对应的零值

- 接下来设置对象的对象头（Object Header）信息，包括对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象GC分代年龄等

- 接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来

- HotSpot解释器的代码片段：略

#### 对象的内存布局

- 对象在内存中存储的布局可以分为3块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）；

- 对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针）。另外如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据。

- 实例数据部分是真正存储的有效信息，也是在代码中所定义的各种类型字段内容。无论是父类继承的还是子类中定义的都需要记录下来。这部分存储的顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。

- 对齐填充不是必然存在的，主要是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。

#### 对象的访问定位

栈上的reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆栈对象的具体位置，目前主流的方式方式有句柄和直接指针两种

- 句柄访问：
Java堆中划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。其最大好处就是reference存储的是稳定的句柄地址，在对象被移到（垃圾收集时移到）只改变实例数据指针，而reference不需要修改

![](http://oi46mo3on.bkt.clouddn.com/10_deep_in_jvm/object_access_reference_1.png)


- 通过直接指针：
Java堆对象的布局中必须考虑如果放置访问类型数据的相关信息，而reference中存在的直接就是对象地址。其最大好处在于速度更快，节省了一次指针定位的时机开销。HotSpot采用该方式进行对象访问，但其他语言和框架采用句柄的也非常常见

![](http://oi46mo3on.bkt.clouddn.com/10_deep_in_jvm/object_access_reference_2.png)


### JVM内存模型

在jvm没存模型中：
- 每个线程有一个工作内存和主存独立
- 工作内存中存放主存中变量值的拷贝

#### 内存模型特性
- 当数据从主存复制到工作内存的时候，需要执行两个操作：
    - 1.由主存执行的read操作
    - 2.由工作内存执行的load操作

- 当数据从工作内存拷贝到主存也需要两个操作：
    - 1.由工作内存执行的store操作
    - 2.由主存执行的write操作
    
以上的操作都是原子的，执行期间不会被中断。对于普通变量，一个线程中更新的值不能马上反应在其他线程中，如果需要其他线程中立即可见需要使用`volatile`关键字

#### 可见性

- 可见性：一个线程修改了变量，其他线程立即知道

- 保证可见性的方法：
    - volatile
    - synchronize(unlock之前，写变量回主存)
    - final(一旦初始化完成，其他线程就可见)

#### 有序性

- 在本线程内，操作都是有序的
- 在线程外观察，操作都是无序的(指令重排序，主内存同步延时)


#### 指令重排序

- 线程内串行语义：
    - 写后读： a=1;b=a; -> 写一个变量后，在读这个位置
    - 写后写： a=1;a=2; -> 写一个变量后，在写这个变量
    - 读后写： a=b;b=1; -> 读一个变量后，在写这个变量
    - 以上语句不可重排
    - 编译器不考虑多线程之间的语义
    - 可重排： a=1;b=2;
    
指令重排-破坏线程的有序性：
``` 
class OrderExample {
    int a = 0;
    int falg = false;
    
    public void write() {
        a = 1;
        flag = true;
    }
    
    public void reader() {
        if(flag) {
            int i = a + 1;
            ....
        }
    }
}
```

上述代码中，i的值是不能保证的：
- 线程A首先执行`write()`
- 线程B接着执行`reader()`，因为指令重排序的原因，线程A执行write的顺序可能会打乱：
``` 
// 线程A
flage = true;
a = 1;
```
线程B读到flag=true后，此时a=0，所以i的值是1


#### 指令重排原则
- 程序顺序原则： 一个线程内保证语义的串行
- volatile规则： volatile变量的写，必然优先于读
- 锁规则： 解锁(unlock)必然发生在随后的加锁(lock)前
- 传递性：A先于B，B先于C，那么A必然先于C
- 线程的`start()`优先于它每一个动作
- 线程的所有操作优先于线程的终结(Thread.join())
- 线程的中断(interrupt())先于被中断的代码
- 对象的构造函数执行结束先于finalize()方法
